metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group:", treatment, sep=" "))
}
# Set up parameters
distance_method <- "euclidean"
clustering_method <- "complete"
# Perform clustering and create dendrogram - CLUST_DF IS SCALED IN THE PREVIOUS CHUNK! IS THAT OKAY???
dist_mat <- dist(clust_df, method = distance_method)
# Elbow method - try to figure out what number of clusters is appropriate
clust_df <- protein_mat
clust_df <- as.data.frame(t(clust_df))
clust_df <- scale(clust_df)
fviz_nbclust(clust_df, kmeans, method = "wss", k.max = 15)
# Create a function that can be used to perform clustering with different k values
perform_clustering <- function(tmp, dist_method, clust_method, num_of_clusters, want_dendrogram = T, want_clust_plot = T) {
# Get distance matrix based on Euclidean distance
dist.euc <- dist(tmp, method = dist_method)
# Perform clustering
tree.complete <- hclust(dist.euc, method = clust_method)
# Plot dendrogram
if (want_dendrogram) {
plot(tree.complete, cex = 0.3,
main = glue("Dendrogram for clustering with {clust_method} link"),
xlab = glue("{dist_method} distance"))
rect.hclust(tree.complete , k = num_of_clusters)
}
if (want_dendrogram) {
dend_obj <- as.dendrogram(tree.complete)
col_dend <- color_branches(dend_obj, k = num_of_clusters)
labels_cex(col_dend)
plot(col_dend)
}
# Visualize clusters
my_clusters <- cutree(tree.complete, k = num_of_clusters)
if (want_clust_plot) {print(fviz_cluster(list(data = tmp, cluster = my_clusters),
main = glue("Clustering by {clust_method} link"),
ggtheme = theme_light()))}
return(my_clusters)
}
# Use this function to do clustering: k = 2
my_clusters <- perform_clustering(clust_df, "euclidean", "complete", 6)
# Set up parameters
distance_method <- "euclidean"
clustering_method <- "complete"
# Perform clustering and create dendrogram - CLUST_DF IS SCALED IN THE PREVIOUS CHUNK! IS THAT OKAY???
dist_mat <- dist(clust_df, method = distance_method)
tree <- hclust(dist_mat, method = clustering_method)
plot(tree, cex = 0.3)
hcd <- as.dendrogram(tree)
# Open a PDF for plotting; units are inches by default
pdf(paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""), width=40, height=15)
# Plot the tree into the PDF
plot(tree, cex = 0.3)
# Close the PDF file's associated graphics device (necessary to finalize the output)
dev.off()
# Rotate PDF
rotate_pdf(
page_rotation = 90,
input_filepath = paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""),
output_filepath = paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""),
overwrite = TRUE
)
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples")
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples")
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = "Treatment",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples")
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples")
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
save_files_to <- "s"
if (save_files_to == "s") {
location_to_save <- "S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0156_WenxiQi-ToleranceEvo/05_DataAnalysis/11_Analysis_Alvaro/"
} else if (save_files_to == "local") {
location_to_save <- paste(base_dir, "ToleranceEvo_Wenxi/", sep="")
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
# Elbow method - try to figure out what number of clusters is appropriate
clust_df <- protein_mat
clust_df <- as.data.frame(t(clust_df))
clust_df <- scale(clust_df)
fviz_nbclust(clust_df, kmeans, method = "wss", k.max = 15)
# Create a function that can be used to perform clustering with different k values
perform_clustering <- function(tmp, dist_method, clust_method, num_of_clusters, want_dendrogram = T, want_clust_plot = T) {
# Get distance matrix based on Euclidean distance
dist.euc <- dist(tmp, method = dist_method)
# Perform clustering
tree.complete <- hclust(dist.euc, method = clust_method)
# Plot dendrogram
if (want_dendrogram) {
plot(tree.complete, cex = 0.3,
main = glue("Dendrogram for clustering with {clust_method} link"),
xlab = glue("{dist_method} distance"))
rect.hclust(tree.complete , k = num_of_clusters)
}
if (want_dendrogram) {
dend_obj <- as.dendrogram(tree.complete)
col_dend <- color_branches(dend_obj, k = num_of_clusters)
labels_cex(col_dend)
plot(col_dend)
}
# Visualize clusters
my_clusters <- cutree(tree.complete, k = num_of_clusters)
if (want_clust_plot) {print(fviz_cluster(list(data = tmp, cluster = my_clusters),
main = glue("Clustering by {clust_method} link"),
ggtheme = theme_light()))}
return(my_clusters)
}
# Use this function to do clustering: k = 2
my_clusters <- perform_clustering(clust_df, "euclidean", "complete", 6)
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group:", treatment, sep=" "))
}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group:", treatment, sep=" "),
sample_name_size = 5)
}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group:", treatment, sep=" "),
sample_name_size = 8)
}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = treatment,
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples",
sample_name_size = 8)
}
View(metadata)
classifications <- c("Strain.Type", "Treatment", "Passage")
for (classification in classifications) {
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = classification,
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples",
sample_name_size = 8)
}
classifications <- c("Strain.Type", "Treatment", "Passage")
for (classification in classifications) {
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = classification,
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples",
sample_name_size = 6)
}
classifications <- c("Strain.Type", "Treatment", "Passage")
for (classification in classifications) {
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = classification,
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "pdf",
plot_name = "default",
heatmap_title = "All samples",
sample_name_size = 5)
}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
save_files_to <- "s"
if (save_files_to == "s") {
location_to_save <- "S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0156_WenxiQi-ToleranceEvo/05_DataAnalysis/11_Analysis_Alvaro/"
} else if (save_files_to == "local") {
location_to_save <- paste(base_dir, "ToleranceEvo_Wenxi/", sep="")
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
classifications <- c("Strain.Type", "Treatment", "Passage")
for (classification in classifications) {
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = classification,
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples",
sample_name_size = 4)
}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
classifications <- c("Strain.Type", "Treatment", "Passage")
for (classification in classifications) {
create_heatmap(protein_mat = protein_mat,
annotation = T,
metadata = metadata,
annotation_type = "single",
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = classification,
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "default",
heatmap_title = "All samples",
sample_name_size = 4)
}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group:", treatment, sep=" "),
sample_name_size = 8)
}
