library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "))
}
gc()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "))
}
gc()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "))
}
gc()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "))
}
gc()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "))
}
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(preprocessCore)
library(proDA)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
working_from <- "charite"
if (working_from == "home") {
base_dir = "/home/alvaro/MyStuff/"
} else
if (working_from == "charite") {
base_dir = "C:/MyStuff/"
}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)
# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))
# Correspondence between precursor IDs and protein IDs (UniProt)
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))
# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
protein_ids = precursor_protein_correspondence$Protein.Ids,
method = "limpa")
protein_mat <- summarization_results$y.protein$E
# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id")
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]
for (treatment in treatments) {
# Subset the protein matrix to contain only the samples in this treatment group
samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
# Subset the metadata
meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
# Produce the heatmap - by Strain.Type
create_heatmap(protein_mat = mat,
annotation = T,
annotation_type = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
color_palette_2 = "magma",
metadata_column_for_annotation = "Strain.Type",
metadata_column_for_annotation_2 = "Passage",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/heatmaps/", sep=""),
save_as = "png",
plot_name = "custom",
custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "))
}
