---
title: "ToleranceEvo_main"
author: "Álvaro Gómez Pérez"
date: "2025-07-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Libraries
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
library(jsonlite)
library(wesanderson)
library(ggrepel)
library(forcats)
```

Set up
```{r}
working_from <- "home"

if (working_from == "home") {
  base_dir = "/home/alvaro/MyStuff/"
} else
  if (working_from == "charite") {
    base_dir = "C:/MyStuff/"
  }

save_files_to <- "local"
if (save_files_to == "s") {
  location_to_save <- "S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0156_WenxiQi-ToleranceEvo/05_DataAnalysis/11_Analysis_Alvaro/"
} else if (save_files_to == "local") {
  location_to_save <- paste(base_dir, "ToleranceEvo_Wenxi/", sep="")
}


# Significance level used for defining proteins as DE
alpha <- 0.05

# Significance level above as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")

# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.1

# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
```

Load data
```{r}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)

# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))

# Correspondence between precursor IDs and protein IDs (UniProt) 
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))

# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
```



# 0. Some QC plots of the fully processed precursor-level data before anything else
```{r}
# Switch this data from wide format to long format - necessary to be able to plot 
temp <- as.data.frame(raw_prec_data)
temp$Precursor.Id <- rownames(temp)
metadata_temp <- metadata %>%
  dplyr::select(Sample.Name, Injection)
prec_data_long <- temp %>%
  pivot_longer(cols = -Precursor.Id, 
               names_to = "Sample.Name",
               values_to = "Precursor.Normalized") %>%
  left_join(metadata_temp, by = "Sample.Name")

# Boxplot for precursor intensities along injection date
ggplot(data = prec_data_long, aes(x = Injection, y = Precursor.Normalized, group = Injection))+
  geom_boxplot() +
  theme_light()
```




# 1. Differential expression analysis
Performed with limpa. Filtering and pre-processing at the precursor level was done in the cluster, here I start from the processed (filtered, normalized, drift corrected, MAR-only imputed) data at precursor level in wide format (precursors in rows, samples in columns), summarize to protein level and perform DE analysis, both with limpa.

## 1.1. Peptide to protein summarization - NOT USED AT THE MOMENT SINCE I ALREADY DID IT ONCE
```{r}
## Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor rawdata - this is, I create a vector #with the same length as the columns of this dataframe, where each entry is the name of the protein corresponding to the precursor in that row in the dataframe. 
#precursor_protein_correspondence <- precursor_protein_correspondence %>%
#  dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
#precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]
#
#
## Remove QC samples
#raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]
#
## Run summarization to protein level - this is the algorithm that takes the precursor abundances and returns protein abundances
#summarization_results <- protein_summarize(raw_data = raw_prec_data,
#                                           protein_ids = precursor_protein_correspondence$Protein.Ids,
#                                           method = "limpa")
#protein_mat <- summarization_results$y.protein$E
#
## Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET, but might be necessary if I change my #pre-processing
##protein_mat <- as.data.frame(protein_mat)
##protein_mat$Precursor.Id <- rownames(protein_mat)
##protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
##                                 cols = !Precursor.Id,
##                                 names_to = "Strain.Name",
##                                 values_to = "Protein.Intensity") %>%
##  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work #(it's based on the     #     #                                                                                    row being present or not, not on its #contents)
##  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
##  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
##              values_from = "Protein.Intensity") %>%
##  as.data.frame() %>%
##  set_column_as_rownames("Precursor.Id") 
##sum(is.na(protein_mat))
##sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))
#
## Save protein level dataset so that we don't need to run summarization every time
#saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
#
## Quickly look at the distribution of the protein abundances
#protein_abundances_long <- pivot_longer(as.data.frame(protein_mat), cols = everything(), names_to = "Sample.Name", values_to = "Abundance")
#ggplot(data = protein_abundances_long, aes(x = Sample.Name, y = Abundance)) +
#  geom_boxplot() +
#  theme_light()
```


## 1.2. Clustering analysis
Load protein-level data so I don't have to run the code above every time
```{r}
summarization_results <- readRDS(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
protein_mat <- summarization_results$y.protein$E
```

Perform hierarchical clustering
```{r}
# Elbow method - try to figure out what number of clusters is appropriate 
clust_df <- protein_mat
clust_df <- as.data.frame(t(clust_df))         
clust_df <- scale(clust_df)

fviz_nbclust(clust_df, kmeans, method = "wss", k.max = 15)


# Create a function that can be used to perform clustering with different k values 
perform_clustering <- function(tmp, dist_method, clust_method, num_of_clusters, want_dendrogram = T, want_clust_plot = T) {
  # Get distance matrix based on Euclidean distance
  dist.euc <- dist(tmp, method = dist_method)
  
  # Perform clustering
  tree.complete <- hclust(dist.euc, method = clust_method)
  
  # Plot dendrogram
  if (want_dendrogram) {
    plot(tree.complete, cex = 0.3, 
         main = glue("Dendrogram for clustering with {clust_method} link"),
         xlab = glue("{dist_method} distance"))
    rect.hclust(tree.complete , k = num_of_clusters)
  }
  
  if (want_dendrogram) {
    dend_obj <- as.dendrogram(tree.complete)
    col_dend <- color_branches(dend_obj, k = num_of_clusters)
    labels_cex(col_dend)
    plot(col_dend)
  }
  
  # Visualize clusters
  my_clusters <- cutree(tree.complete, k = num_of_clusters)
  if (want_clust_plot) {print(fviz_cluster(list(data = tmp, cluster = my_clusters), 
                                           main = glue("Clustering by {clust_method} link"),
                                           ggtheme = theme_light()))}
  
  return(my_clusters)
}


# Use this function to do clustering: k = 2
my_clusters <- perform_clustering(clust_df, "euclidean", "complete", 6)
```

Clustering to save dendrogram to PDF
```{r}
# Set up parameters
distance_method <- "euclidean"
clustering_method <- "complete"

# Perform clustering and create dendrogram - CLUST_DF IS SCALED IN THE PREVIOUS CHUNK! IS THAT OKAY???
dist_mat <- dist(clust_df, method = distance_method)
tree <- hclust(dist_mat, method = clustering_method)
plot(tree, cex = 0.3)
hcd <- as.dendrogram(tree)

# Open a PDF for plotting; units are inches by default
pdf(paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""), width=40, height=15)

# Plot the tree into the PDF
plot(tree, cex = 0.3)

# Close the PDF file's associated graphics device (necessary to finalize the output)
dev.off()

# Rotate PDF
rotate_pdf(
  page_rotation = 90,
  input_filepath = paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""),
  output_filepath = paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""),
  overwrite = TRUE
)
```



## 1.3. Heatmaps
### 1.3.1. Heatmap with Z-score based on median per protein - for all samples
So this is basically focusing on the variability of each protein across all the samples - removing the basal "effect" of that protein?
```{r}
classifications <- c("Strain.Type", "Treatment", "Passage")

for (classification in classifications) {
  create_heatmap(protein_mat = protein_mat,
               metadata = metadata,
               annotation = "single",
               heatmap_type = "z-score",
               z_score_type = "standard",
               color_palette = "viridis",
               metadata_column_for_annotation = classification,
               metadata_column_for_sample_name = "Sample.Name",
               location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
               save_as = "png",
               plot_name = "default",
               heatmap_title = "All samples",
               sample_name_size = 4,
               cluster_columns = F)
}
```

### 1.3.2. Separate heatmaps for each treatment group
Since in the heatmap for all samples together, these cluster only around treatment group, I want to see, within each treatment group, do the samples cluster based on the other parameters?
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by Strain.Type
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Strain.Type",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
  # Produce the heatmap by passage
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Passage",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Passage", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
}
```

### 1.3.3. Let me actually separate this by Strain.Type and Passage at the same time
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by Strain.Type
  create_heatmap(protein_mat = mat,
                 annotation = "double",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 color_palette_2 = "magma",
                 metadata_column_for_annotation = "Strain.Type",
                 metadata_column_for_annotation_2 = "Passage",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
                 heatmap_title = paste("Treatment group:", treatment, sep=" "),
                 sample_name_size = 8,
                 cluster_columns = F)
}
```


## 1.4. PCA
I make 3 different ones, in each of them coloring by a different covariate
```{r}
do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Strain.Type",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")

do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Passage",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")

do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Treatment",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")

metadata <- metadata %>%
  dplyr::mutate(Treatment_Passage = paste(Treatment, Passage, sep="_"))

do_pca(protein_mat, 
       metadata,
       metadata_column_for_annotation = "Treatment_Passage",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")
```



# 2. Introduce phenotypic data
## 2.1. Some initial plots of the tolerance and resistance
```{r}
# Load data
phenotypic_data <- fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/phenotypic_data/processed_phenotypic_data.tsv", sep = ""))
phenotypic_data_all_passages <- fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/phenotypic_data/processed_phenotypic_data_all_passages.tsv", sep = ""))

# Histograms of RAD20 and FoG20
## Throuhgout all passages
ggplot(data = phenotypic_data_all_passages, aes(x = RAD20)) + 
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of RAD20 across all strains", 
       subtitle = "All passages") +
  coord_cartesian(xlim = c(3, 16),
                  ylim = c(0, 12.5))
ggplot(data = phenotypic_data_all_passages, aes(x = FoG20)) + 
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of FoG20 across all strains", 
       subtitle = "All passages") +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(0, 30))

## Through passages 0, 4 and 7
ggplot(data = subset(phenotypic_data_all_passages, Passage %in% c(0, 4, 7)), aes(x = RAD20)) + 
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of RAD20 across all strains", 
       subtitle = "Passages 0, 4 and 7") +
  coord_cartesian(xlim = c(3, 16),
                  ylim = c(0, 12.5))
ggplot(data = subset(phenotypic_data_all_passages, Passage %in% c(0, 4, 7)), aes(x = FoG20)) + 
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of FoG20 across all strains", 
       subtitle = "Passages 0, 4 and 7") +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(0, 30))

# Boxplots of RAD20 and FoG20s grouping by other variables
ggplot(data = phenotypic_data, aes(x = Strain.Type, y = RAD20, group = Strain.Type)) +
  geom_boxplot() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = Strain.Type, y = FoG20, group = Strain.Type)) +
  geom_boxplot() +
  theme_light()

# Scatterplot RAD20 vs. FoG20 and locate strains in that space
ggplot(data = phenotypic_data, aes(x = RAD20, y = FoG20, col = Strain.Name)) +
  geom_point() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = RAD20, y = FoG20, col = Strain.Type)) +
  geom_point() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = RAD20, y = FoG20, col = Passage)) +
  geom_point() +
  theme_light()


# Correlation between Passage and RAD20, and FoG20
cor(phenotypic_data_all_passages$Passage, phenotypic_data_all_passages$RAD20)
cor(phenotypic_data_all_passages$Passage, phenotypic_data_all_passages$FoG20)

# Repeat these correlations, separately for each of the strains - TODO: instead of printing these values, put them into a dataframe and create a barplot!
strain_types <- unique(phenotypic_data_all_passages$Strain.Type)
Strain <- c()
Parameter <- c()
Correlation <- c()

for (i in 1:length(strain_types)) {
  strain_type <- strain_types[i]
  temp <- phenotypic_data_all_passages %>%
    dplyr::filter(Strain.Type == strain_type)
  
  for (parameter in c("RAD20", "FoG20")) {
    Strain <- c(Strain, strain_type)
    Parameter <- c(Parameter, parameter)
    Correlation <- c(Correlation, abs(cor(temp$Passage, temp[[parameter]])))
  }
}

correlations_to_passage <- data.frame(Strain, Parameter, Correlation)

ggplot(correlations_to_passage, aes(x = Parameter, y = Correlation, fill = Strain)) +
  geom_col(position = "dodge", col = "grey") +
  theme_light() +
  coord_cartesian(ylim = c(0, 1)) +
  labs(title = "Correlation between passage and tolerance or resistance") +
  #scale_fill_viridis_d(option = "mako")
  scale_fill_manual(values= wes_palette("FantasticFox1", n = 3))
```


## 2.2. Heatmaps - informed by resistance and tolerance levels
### 2.3.1. First of all, add RAD20 and FoG20 to the metadata
```{r}
temp <- phenotypic_data %>%
  dplyr::select(Sample.Name, RAD20, FoG20)
metadata <- left_join(metadata, temp, by = "Sample.Name")
```

### 2.2.2. All samples together
```{r}
# Don't know why I didn't have this issue before, but need to remove QCs first (otherwise there are NAs in the annotation column)
protein_mat_no_QCs <- protein_mat[, !grepl("QC", colnames(protein_mat))]

# By RAD20
create_heatmap(protein_mat = protein_mat_no_QCs,
             metadata = metadata,
             annotation = "single",
             heatmap_type = "z-score",
             z_score_type = "standard",
             color_palette = "viridis",
             metadata_column_for_annotation = "RAD20",
             metadata_column_for_sample_name = "Sample.Name",
             location_to_save = paste(location_to_save, "Output/Plots/heatmaps/phenotypic/", sep=""),
             save_as = "png",
             plot_name = "default",
             heatmap_title = "All samples",
             sample_name_size = 4,
             cluster_columns = F)

# By FoG20
create_heatmap(protein_mat = protein_mat_no_QCs,
             metadata = metadata,
             annotation = "single",
             heatmap_type = "z-score",
             z_score_type = "standard",
             color_palette = "viridis",
             metadata_column_for_annotation = "FoG20",
             metadata_column_for_sample_name = "Sample.Name",
             location_to_save = paste(location_to_save, "Output/Plots/heatmaps/phenotypic/", sep=""),
             save_as = "png",
             plot_name = "default",
             heatmap_title = "All samples",
             sample_name_size = 4,
             cluster_columns = F)
```

### 2.2.3. Separate by treatment groups
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by RAD20
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "RAD20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/phenotypic/", sep=""),
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_RAD20", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
  # Produce the heatmap - by FoG20
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "FoG20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/phenotypic/", sep=""),
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_FoG20", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
    # Produce the heatmap - by RAD20 and passage
  create_heatmap(protein_mat = mat,
                 annotation = "double",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Passage",
                 metadata_column_for_annotation_2 = "RAD20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/phenotypic/", sep=""),
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_RAD20_and_passage", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
  # Produce the heatmap - by FoG20 and passage
  create_heatmap(protein_mat = mat,
                 annotation = "double",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Passage",
                 metadata_column_for_annotation_2 = "FoG20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/phenotypic/", sep=""),
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_FoG20_and_passage", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
}
```




# 3. Differential expression analysis
## 3.1. Perform DE analysis
### 3.1.1. Pellet samples, high tolerance vs. low - no significance
```{r}
# Set up
treatment <- "Pellet"
parameter <- "Tolerance"

# Grab only liquid treatment samples
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- "Low"
metadata_subset <- metadata %>%
  dplyr::filter(Sample.Name %in% samples_to_select) %>%
  dplyr::select(-Strain.Name) %>%
  dplyr::rename(Strain.Name = parameter)

# DELETE THIS PART - SAVE THE DATA JUST AS IT IS PROVIDED HERE, TO TEST THE DE_ANALYSIS FUNCTION
saveRDS(temp_protein_mat, "/home/alvaro/MyStuff/temp_protein_mat.rds")
saveRDS(metadata_subset, "/home/alvaro/MyStuff/metadata_subset.rds")

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", treatment, "_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Add other informative columns to resp df
temp <- metadata %>%
  dplyr::select(Strain.Name, Strain.Type, Treatment, Passage) %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
resp <- left_join(resp, temp, by = "Strain.Name")


# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

### 3.1.2. Pellet samples, high resistance vs. low - no significance
```{r}
# Set up
treatment <- "Pellet"
parameter <- "Resistance"

# Grab only liquid treatment samples
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- "Low"
metadata_subset <- metadata %>%
  dplyr::filter(Sample.Name %in% samples_to_select) %>%
  dplyr::select(-Strain.Name) %>%
  dplyr::rename(Strain.Name = parameter)

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", treatment, "_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Add other informative columns to resp df
temp <- metadata %>%
  dplyr::select(Strain.Name, Strain.Type, Treatment, Passage) %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
resp <- left_join(resp, temp, by = "Strain.Name")

# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

### 3.1.3. Liquid samples, high tolerance vs. low - no significance
```{r}
# Set up
treatment <- "Liquid"
parameter <- "Tolerance"

# Grab only liquid treatment samples
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- "Low"
metadata_subset <- metadata %>%
  dplyr::filter(Sample.Name %in% samples_to_select) %>%
  dplyr::select(-Strain.Name) %>%
  dplyr::rename(Strain.Name = parameter)

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", treatment, "_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Add other informative columns to resp df
temp <- metadata %>%
  dplyr::select(Strain.Name, Strain.Type, Treatment, Passage) %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
resp <- left_join(resp, temp, by = "Strain.Name")

# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

### 3.1.4. Liquid samples, high resistance vs. low - no significance
```{r}
# Set up
treatment <- "Liquid"
parameter <- "Resistance"

# Grab only liquid treatment samples
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- "Low"
metadata_subset <- metadata %>%
  dplyr::filter(Sample.Name %in% samples_to_select) %>%
  dplyr::select(-Strain.Name) %>%
  dplyr::rename(Strain.Name = parameter)

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", treatment, "_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Add other informative columns to resp df
temp <- metadata %>%
  dplyr::select(Strain.Name, Strain.Type, Treatment, Passage) %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
resp <- left_join(resp, temp, by = "Strain.Name")

# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

### 3.1.5. All samples, compare liquid and fluconazole vs. pellet - no significance
```{r}
# Set up
parameter <- "Treatment"

# Grab only liquid treatment samples
temp_protein_mat <- protein_mat
reference_strain <- "Pellet"
metadata_subset <- metadata %>%
  dplyr::select(-Strain.Name) %>%
  dplyr::rename(Strain.Name = parameter)

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_all_samples_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

### 3.1.6. Pellet samples, passages 4 and 7 vs. passage 0 - no significance
```{r}
# Set up
treatment <- "Pellet"
parameter <- "Passage"

# Grab only liquid treatment samples
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- "Passage_0"
metadata_subset <- metadata %>%
  dplyr::filter(Sample.Name %in% samples_to_select) %>%
  dplyr::select(-Strain.Name) %>%
  dplyr::mutate(Passage = paste("Passage_", Passage, sep="")) %>%
  dplyr::rename(Strain.Name = parameter)

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", treatment, "_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

### 3.1.7. Liquid samples, passages 4 and 7 vs. passage 0 - no significance
```{r}
# Set up
treatment <- "Liquid"
parameter <- "Passage"

# Grab only liquid treatment samples
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- "Passage_0"
metadata_subset <- metadata %>%
  dplyr::filter(Sample.Name %in% samples_to_select) %>%
  dplyr::select(-Strain.Name) %>%
  dplyr::mutate(Passage = paste("Passage_", Passage, sep="")) %>%
  dplyr::rename(Strain.Name = parameter)

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", treatment, "_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

### 3.1.8. Pellet samples, per actual strain - no significance
```{r}
# Set up
treatment <- "Pellet"
parameter <- "Strain.Name"

# Grab only liquid treatment samples
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- "C0P"
metadata_subset <- metadata %>%
  dplyr::filter(Sample.Name %in% samples_to_select)

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata_subset,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", treatment, "_", parameter, "_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 0.5,
                                 alpha = 0.05)

# Histograms of logFC and p-values
ggplot(data = da, aes(x = logFC)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("logFCs for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = P.Value)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Raw p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))

ggplot(data = da, aes(x = adj.P.Val)) +
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  labs(title = paste("Adjusted p-values for DEA by", parameter, sep=" "),
       subtitle = paste("For", treatment, "samples", sep=" "))
```

--> Probably just delete all of these, they are a bit naive, I am not taking into account the collinearity between Passage and Resistance/Tolerance, nor the effect of all variables at once: this is, I separate by treatment sometimes, which is nice, so I don't get that mixed up with what I am trying to model (the relationship between resistance/tolerance and protein expression), however I don't do the same for the strain type! 

--> So what I am going to do now is fit a model which accounts for all variables (except Passage, which I am leaving out to avoid collinearity with tolerance/resistance, assuming that all the relevant information that Passage can provide is present in resistance/tolerance as well - THIS ASSUMPTION I SHOULD THINK MORE ABOUT), this is, contains as regressors: resistance/tolerance, strain type and treatment. In this way, the effect of strain type and treatment is accounted for instead of it being treated as noise, which will make it easier for the model to find an effect of resistance/tolerance. Then, I can interpret the logFCs and the p-values for the resistance/tolerance variable, although I think that logFC needs to be interpreted in a slightly different way from usually! NEED TO MAKE SURE TO LOOK INTO THIS. 

For resistance
```{r}
raw_data <- protein_mat[, !grepl("QC", colnames(protein_mat))]

# Make sure column order matches
metadata <- metadata[match(colnames(raw_data), metadata$Sample.Name), ] %>%
  dplyr::mutate(Resistance = -RAD20)

# Design matrix
design <- model.matrix(~ Resistance + Treatment + Strain.Type, data = metadata)
colnames(design)
# The first column (Intercept) is baseline expression
# The second column (Resistance) is your variable of interest

# Fit model
fit <- lmFit(raw_data, design)
fit <- eBayes(fit)

# Extract results for the 'Resistance' coefficient
resistance_results <- topTable(fit, coef = "Resistance", number = Inf, adjust.method = "BH")
resistance_results_strain_type_tolerant <- topTable(fit, coef = "Strain.TypeHigh tolerance", number = Inf, adjust.method = "BH")
resistance_results_strain_type_lab <- topTable(fit, coef = "Strain.TypeLab strain", number = Inf, adjust.method = "BH")
resistance_results_treatment_liquid <- topTable(fit, coef = "TreatmentLiquid", number = Inf, adjust.method = "BH")
resistance_results_treatment_pellet <- topTable(fit, coef = "TreatmentPellet", number = Inf, adjust.method = "BH")

# Add protein IDs
resistance_results <- tibble::rownames_to_column(resistance_results, var = "protein")

# Classify as up/down associated
resistance_results <- resistance_results %>%
  mutate(
    diffexpressed_adjusted = case_when(
      (logFC > 0 & adj.P.Val < 0.05) ~ "Positively_correlated_with_resistance",
      (logFC < 0 & adj.P.Val < 0.05) ~ "Negatively_correlated_with_resistance",
      TRUE ~ "Not_significant"
    )
  )

# Quick summary
table(resistance_results$diffexpressed_adjusted)


# Volcano plot
ggplot(data = resistance_results, aes(x = logFC, y = -log10(adj.P.Val))) +
  geom_point() +
  theme_light() +
  geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
  labs(title = "Differentially abundant proteins with respect to resistance") +
  geom_vline(xintercept = 0.05, col = "orange", linewidth = 1) +
  geom_vline(xintercept = -0.05, col = "orange", linewidth = 1)








# Correlation heatmap - #TODO: STILL NEED TO LOOK INTO HOW TO MAKE THIS BETTER!
## Select top positively and negatively correlated proteins
top_pos <- resistance_results %>%
  arrange(desc(logFC)) %>%
  slice_head(n = 15) %>%
  pull(protein)

top_neg <- resistance_results %>%
  arrange(logFC) %>%
  slice_head(n = 15) %>%
  pull(protein)

top_proteins <- c(top_pos, top_neg)

## Subset expression matrix
expr_subset <- raw_data[top_proteins, ]

## Optionally order samples by Resistance level
sample_order <- order(metadata$RAD20)
expr_subset <- expr_subset[, sample_order]
annotation_col <- metadata[sample_order, c("Resistance", "Treatment")]

## Plot heatmap
# --- Step 1: Z-score (row-scale) the expression matrix manually
expr_scaled <- t(scale(t(expr_subset)))  # same as pheatmap(scale="row")

# --- Step 2: Prepare column annotations
# Convert annotation_col to a HeatmapAnnotation object
# You can specify colors if you like, or let ComplexHeatmap choose automatically

ha_col <- HeatmapAnnotation(
  df = annotation_col,
  col = list(
    Treatment = structure(
      RColorBrewer::brewer.pal(length(unique(annotation_col$Treatment)), "Set2"),
      names = unique(annotation_col$Treatment)
    ),
    # Optional: color scale for numeric variables
    Resistance = colorRamp2(
      c(min(annotation_col$Resistance), max(annotation_col$Resistance)),
      c("blue", "red")
    )
  ),
  annotation_height = unit(0.8, "cm")
)

# --- Step 3: Draw the heatmap
Heatmap(
  expr_scaled,
  name = "Z-score",
  top_annotation = ha_col,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  clustering_method_rows = "complete",
  clustering_method_columns = "complete",
  column_title = "Top proteins correlated with resistance",
  row_title = "Proteins",
  heatmap_legend_param = list(title = "Expression (Z)")
)

```

Check how important Strain.Type and Treatment are in fitting the model
```{r}
hist(resistance_results$adj.P.Val, main = "Resistance adj. p-values")
hist(resistance_results_strain_type_tolerant$adj.P.Val, main = "Tolerant strain adj. p-values")
hist(resistance_results_strain_type_lab$adj.P.Val,      main = "Lab strain adj. p-values")
hist(resistance_results_treatment_liquid$adj.P.Val,     main = "Liquid treatment adj. p-values")
hist(resistance_results_treatment_pellet$adj.P.Val,     main = "Pellet treatment adj. p-values")
```


For tolerance
```{r}
raw_data <- protein_mat[, !grepl("QC", colnames(protein_mat))]

# Make sure column order matches
metadata <- metadata[match(colnames(raw_data), metadata$Sample.Name), ]

# Design matrix
design <- model.matrix(~ FoG20 + Treatment + Strain.Type, data = metadata)
colnames(design)
# The first column (Intercept) is baseline expression
# The second column (FoG20) is your variable of interest

# Fit model
fit <- lmFit(raw_data, design)
fit <- eBayes(fit)

# Extract results for the 'FoG20' coefficient
FoG20_results <- topTable(fit, coef = "FoG20", number = Inf, adjust.method = "BH")
FoG20_results_strain_type_tolerant <- topTable(fit, coef = "Strain.TypeHigh tolerance", number = Inf, adjust.method = "BH")
FoG20_results_strain_type_lab <- topTable(fit, coef = "Strain.TypeLab strain", number = Inf, adjust.method = "BH")
FoG20_results_treatment_liquid <- topTable(fit, coef = "TreatmentLiquid", number = Inf, adjust.method = "BH")
FoG20_results_treatment_pellet <- topTable(fit, coef = "TreatmentPellet", number = Inf, adjust.method = "BH")

# Add protein IDs
FoG20_results <- tibble::rownames_to_column(FoG20_results, var = "protein")

# Classify as up/down associated
FoG20_results <- FoG20_results %>%
  mutate(
    diffexpressed_adjusted = case_when(
      (logFC > 0 & adj.P.Val < 0.05) ~ "Positively_correlated_with_FoG20",
      (logFC < 0 & adj.P.Val < 0.05) ~ "Negatively_correlated_with_FoG20",
      TRUE ~ "Not_significant"
    )
  )

# Quick summary
table(FoG20_results$diffexpressed_adjusted)


# Volcano plot
ggplot(data = FoG20_results, aes(x = logFC, y = -log10(adj.P.Val))) +
  geom_point() +
  theme_light() +
  geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
  geom_vline(xintercept = 0.5, col = "orange", linewidth = 1) +
  geom_vline(xintercept = -0.5, col = "orange", linewidth = 1) +
  labs(title = "Differentially abundant proteins with respect to tolerance")


# Correlation heatmap
## Select top positively and negatively correlated proteins
top_pos <- FoG20_results %>%
  arrange(desc(logFC)) %>%
  slice_head(n = 15) %>%
  pull(protein)

top_neg <- FoG20_results %>%
  arrange(logFC) %>%
  slice_head(n = 15) %>%
  pull(protein)

top_proteins <- c(top_pos, top_neg)

## Subset expression matrix
expr_subset <- raw_data[top_proteins, ]

## Optionally order samples by FoG20 level
sample_order <- order(metadata$FoG20)
expr_subset <- expr_subset[, sample_order]
annotation_col <- metadata[sample_order, c("FoG20", "Treatment")]

## Plot heatmap
# --- Step 1: Z-score (row-scale) the expression matrix manually
expr_scaled <- t(scale(t(expr_subset)))  # same as pheatmap(scale="row")

# --- Step 2: Prepare column annotations
# Convert annotation_col to a HeatmapAnnotation object
# You can specify colors if you like, or let ComplexHeatmap choose automatically

ha_col <- HeatmapAnnotation(
  df = annotation_col,
  col = list(
    Treatment = structure(
      RColorBrewer::brewer.pal(length(unique(annotation_col$Treatment)), "Set2"),
      names = unique(annotation_col$Treatment)
    ),
    # Optional: color scale for numeric variables
    FoG20 = colorRamp2(
      c(min(annotation_col$FoG20), max(annotation_col$FoG20)),
      c("blue", "red")
    )
  ),
  annotation_height = unit(0.8, "cm")
)

# --- Step 3: Draw the heatmap
Heatmap(
  expr_scaled,
  name = "Z-score",
  top_annotation = ha_col,
  show_row_names = TRUE,
  show_column_names = FALSE,
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  clustering_method_rows = "complete",
  clustering_method_columns = "complete",
  column_title = "Top proteins correlated with FoG20",
  row_title = "Proteins",
  heatmap_legend_param = list(title = "Expression (Z)")
)

```

Check how important Strain.Type and Treatment are in fitting the model
```{r}
hist(FoG20_results$adj.P.Val, main = "Tolerance adj. p-values")
hist(FoG20_results_strain_type_tolerant$adj.P.Val, main = "Tolerant strain adj. p-values")
hist(FoG20_results_strain_type_lab$adj.P.Val, main = "Lab strain adj. p-values")
hist(FoG20_results_treatment_liquid$adj.P.Val, main = "Liquid treatment adj. p-values")
hist(FoG20_results_treatment_pellet$adj.P.Val, main = "Pellet treatment adj. p-values")
```


Some sanity checks - STILL NEED TO GO THROUGH THIS
```{r}
# Check collinearity
car::vif(lm(RAD20 ~ Treatment + Strain.Type, data = metadata))
car::vif(lm(FoG20 ~ Treatment + Strain.Type, data = metadata))

# Correlation between Passage and Resistance
cor(metadata$Passage, metadata$RAD20, use = "pairwise.complete.obs")
cor(metadata$Passage, metadata$FoG20, use = "pairwise.complete.obs")

# Plot some examples
example_protein <- resistance_results$protein[1]
df_plot <- data.frame(
  Expression = raw_data[example_protein, ],
  Resistance = metadata$RAD20,
  Treatment = metadata$Treatment)
ggplot(df_plot, aes(x = RAD20, y = Expression, color = Treatment)) +
  geom_point(size = 2) +
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle(example_protein)

example_protein <- resistance_results$protein[1]
df_plot <- data.frame(
  Expression = raw_data[example_protein, ],
  Resistance = metadata$FoG20,
  Treatment = metadata$Treatment)
ggplot(df_plot, aes(x = FoG20, y = Expression, color = Treatment)) +
  geom_point(size = 2) +
  geom_smooth(method = "lm", se = FALSE) +
  ggtitle(example_protein)
```







--> Going to do a GSEA for the up- and down- regulated proteins in tolerance, since in resistance we can't really see much

# 3. GSEA
Load data
```{r}
# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/uniprotkb_proteome_UP000000559_2025_10_19.tsv", sep="")))
```


## 3.1. Prepare ranked gene lists
For now, my score/rank is: sign(logFC)*(-log10(adj.P.Val))
```{r}
# Get the corresponding KEGG IDs to these UniProt gene names, since the GSEA is performed in terms of those
temp_entrez <- entrez_db %>%
  dplyr::select(Entry, GeneID) %>%
  dplyr::rename(uniprot = Entry) %>%
  dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))

FoG20_results <- FoG20_results %>%
  dplyr::rename(uniprot = protein) %>%
  left_join(temp_entrez, by = "uniprot")

# Using as score the -log10(p-value)*sign of the logFC
rankings <- sign(FoG20_results$logFC)*(-log10(FoG20_results$adj.P.Val))
names(rankings) <- FoG20_results$GeneID
rankings <- sort(rankings, decreasing = TRUE)

# Plot
plot(rankings)

# Check max and min - to see if there is a need to correct for -Inf and +Inf - commented out, I don't think it's necessary
#print(max(rankings))
#print(min(rankings))

# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
# (this part is copy pasted from the link)
max_ranking <- max(rankings[is.finite(rankings)])
min_ranking <- min(rankings[is.finite(rankings)])
rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
rankings <- sort(rankings, decreasing = TRUE)                                   # sort genes by ranking

# Get rid of rankings with emtpy names and with repeated names
length(rankings)
rankings <- rankings[!is.na(names(rankings)) & names(rankings) != ""]
rankings <- rankings[!duplicated(names(rankings))]
length(rankings)


# Save this ranked lists so that I can use them later to pick the top 50 proteins in each strain, to look at the overlaps between major strains within families in a more unbiased manner - not really feasible for now since the distribution of the scores for the vast majority of strains is pretty much flat. I wonder how much this affects my DEA?
#write_json(ranked_genes, path = paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/lists_of_ranked_genes_", alpha_plain, "_logFC_", as.character(lfc_threshold), sep=""), pretty = T)
```

## 3.2. Perform GSEA with KEGG annotation - as described by https://biostatsquid.com/fgsea-tutorial-gsea/
### Download KEGG gene lists (according to https://www.researchgate.net/post/How_i_can_get_a_list_of_KEGG_pathways_and_its_list_of_genes)
DO NOT RUN AGAIN - I used this to download the .gmt file, I just need to load it, but I left this code here in case I want to know how I did it
```{r}
#library("KEGGREST")
#library("EnrichmentBrowser")
#
##step2: check and obtain a list of entry identifiers (in this case: sce) and associated definition for a given database r a given set of database entries.
#MRSA252 <- keggList("cal")
#
##step 3: download the pathways of that organism:
#sarpathway <- downloadPathways("cal")
#
##step 4: retrieve gene sets for an organism from databases such as GO and KEGG:
#sar <- getGenesets(org = "cal", db = "kegg", cache = TRUE, return.type="list")
#
##step5: Parse and write the gene sets to a flat text file in GMT format for other pathway enrichment analysis programs (e.g., GSEA):
#writeGMT(sar, gmt.file = paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt", sep=""))
```

### Process .gmt file to turn it into the list of gene set vectors we need for gsea()
Get a list of pathways, with each entry being a vector with the Entrez IDs for the genes involved in that pathway. Make it so that only proteins that we detect in our dataset are included here. 
```{r}
# Read in the .gmt file
library(qusage)
gmt <- read.gmt(paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt", sep=""))
gmt$term <- as.character(gmt$term)

# Get a simple vector with the Entrez IDs of the proteins we detect - now we already have it! It's temp_entrez$GeneID :)
proteins_detected <- temp_entrez$GeneID

# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)

kegg_genes <- lapply(names(gmt), function(pathway) {
  intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
```

### Run GSEA
The warning I get here refers to many proteins having exactly the same rank (these are the ones we see in a horizontal line in the plots produced in 5.1.) - this should be okay, since these are the genes that were not significantly differentially expressed at all - but tbh this makes it so that I cannot really get that much info from those anyway, right? So there isn't that much of a difference between this and doing the GSEA only with DE proteins, right?? Idk
```{r}
library(fgsea)
fgseaRes <- fgsea(
  pathways = kegg_genes,
  stats = rankings,
  minSize = 10,
  maxSize = 500)

# Save these results
fwrite(fgseaRes, paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/kegg_gsea_results_tolerance_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".tsv", sep=""))
```

### Get a volcano plot for the GSEA results
```{r}
fgseaRes <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/kegg_gsea_results_tolerance_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".tsv", sep="")))

ggplot(data = fgseaRes, aes(x = NES, y = -log10(padj))) +
  geom_point() +
  geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
  theme_light() +
  xlab("Normalized Enrichment Score") +
  ylab("-log10(Adjusted p-value)") +
  labs(title = "KEGG pathways enriched with respect to tolerance") +
  geom_label_repel(data = subset(fgseaRes, NES > 1.5 & -log10(padj) > -log10(0.05)),
                   aes(x = NES, y = -log10(padj), label = pathway))
```

### Not too practical since pathway names are too long to fit in there, let me try a barplot:
```{r}
fgseaRes <- fgseaRes %>%
  dplyr::mutate(direction = case_when(
    NES > 0 ~ "Up-regulated",
    NES < 0 ~ "Down-regulated",
    TRUE    ~ "Neutral")) %>%
  dplyr::mutate(pathway = str_replace_all(str_remove(pathway, "^[^_]*_"), "_", " "))

top_pathways <- fgseaRes %>%
  dplyr::filter(padj < 0.05) %>%
  arrange(padj)

ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
  geom_col() +
  coord_flip() +   # horizontal bars
  scale_fill_manual(values = c("Up-regulated" = "firebrick", "Down-regulated" = "steelblue")) +
  labs(x = "Pathway",
       y = "Normalized Enrichment Score (NES)",
       title = "Top enriched pathways with respect to resistance") +
  theme_minimal(base_size = 14) +
  theme(plot.title = element_text(size = 13))  # set smaller title font here)
```
















