metadata_column_for_annotation = "FoG20",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
save_as = "png",
plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_FoG20", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "),
cluster_columns = F,
sample_name_size = 4)
# Produce the heatmap - by RAD20 and passage
create_heatmap(protein_mat = mat,
annotation = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = "Passage",
metadata_column_for_annotation_2 = "RAD20",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
save_as = "png",
plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_RAD20_and_passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "),
cluster_columns = F,
sample_name_size = 4)
# Produce the heatmap - by FoG20 and passage
create_heatmap(protein_mat = mat,
annotation = "double",
metadata = meta,
heatmap_type = "z-score",
z_score_type = "standard",
color_palette = "viridis",
metadata_column_for_annotation = "Passage",
metadata_column_for_annotation_2 = "FoG20",
metadata_column_for_sample_name = "Sample.Name",
location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
save_as = "png",
plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_FoG20_and_passage", sep=""),
heatmap_title = paste("Treatment group", treatment, sep=" "),
cluster_columns = F,
sample_name_size = 4)
}
# First of all, need to remove the QC samples from the protein abundance dataset - not sure if this is necessary anymore?
raw_data <- protein_mat[, !grepl("QC", colnames(protein_mat))]
# Since we are going to start an iteration before, we first create an empty list where we can save the output of each of the iterations
list_for_de_results <- list()
# Iterate over the 3 treatments
treatments <- unique(metadata$Treatment)[!unique(metadata$Treatment) %in% c("QC")]          # grab the treatment names to iterate over them
for (i in 1:length(treatments)) {                                                           # iterate over treatment groups
treatment <- treatments[i]
samples_to_select <- metadata$Sample.Name[metadata$Treatment == treatment]              # grab the names of the samples in this treatment group
protein_data_treatment <- protein_mat[, colnames(protein_mat) %in% samples_to_select]   # remove all samples from the protein dataset that don't belong to this treatment group
# Make sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata[match(colnames(protein_data_treatment), metadata$Sample.Name), ]
# FOR RESISTANCE
# Create a design matrix - this is the matrix that tells the DE algorithm which samples belong to the same group
design <- model.matrix(~ Resistance + Strain.Type, data = metadata_sorted)
# Fit model
fit <- lmFit(protein_data_treatment, design)
fit <- eBayes(fit)
# Extract results for the 'Resistance' coefficient of the fitted model
resistance_results <- topTable(fit, coef = "Resistance", number = Inf, adjust.method = "BH")
# The protein IDs are in the rownames now, let's put them in a column instead
resistance_results <- tibble::rownames_to_column(resistance_results, var = "protein")
# Now we save this dataframe with the results of the DE analysis to the empty list we created above, while specifying the name of the parameter used and the treatment
list_for_de_results[[paste(treatment, "_resistance", sep="")]] <- resistance_results
# FOR TOLERANCE
# Create a design matrix - this is the matrix that tells the DE algorithm which samples belong to the same group
design <- model.matrix(~ FoG20 + Strain.Type, data = metadata_sorted)
# Fit model
fit <- lmFit(protein_data_treatment, design)
fit <- eBayes(fit)
# Extract results for the 'Resistance' coefficient of the fitted model
tolerance_results <- topTable(fit, coef = "FoG20", number = Inf, adjust.method = "BH")
# The protein IDs are in the rownames now, let's put them in a column instead
tolerance_results <- tibble::rownames_to_column(tolerance_results, var = "protein")
# Now we save this dataframe with the results of the DE analysis to the empty list we created above, while specifying the name of the parameter used and the treatment
list_for_de_results[[paste(treatment, "_tolerance", sep="")]] <- tolerance_results
}
# We iterate over the dataframes in the list, each of them contains the reults from DEA for one of the treatments for tolerance or resistance, and we create the same plot for all of them
for (i in 1:length(list_for_de_results)) {
df <- list_for_de_results[[i]]
name <- names(list_for_de_results)[i]
p <- ggplot(data = df, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +      # this adds the horizontal line at p-value = 0.05
labs(title = glue("Differentially abundant proteins for {name}")) +          # this creates the plot title
geom_vline(xintercept = mean(df$logFC)+2*sd(df$logFC), col = "orange", linewidth = 1) + # this line and the following create the vertical lines, for a logFC threshold
geom_vline(xintercept = mean(df$logFC)-2*sd(df$logFC), col = "orange", linewidth = 1)   # since this threshold would be different across these plots, I set it at the +-2*SD of the logFC distribution
print(p)
}
View(list_for_de_results)
View(list_for_de_results)
levels_in_variable
View(protein_mat)
# First of all, make sure you get a version of the protein matrix and of the metadata which contain only the samples that you want to analyze
# For example, let's say that you want to compare strains C7P and H7P, then you will do this:
protein_mat_temp <- protein_mat[, grepl("C7P", colnames(protein_mat))|grepl("H7P", colnames(protein_mat))]
View(protein_mat_temp)
metadata_temp <- metadata %>%
dplyr::filter(Sample.Name == "C7P"|"H7P")
metadata_temp <- metadata %>%
dplyr::filter(Sample.Name == "C7P"| Sample.Name == "H7P")
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
View(metadata_temp)
# First of all, make sure you get a version of the protein matrix and of the metadata which contain only the samples that you want to analyze
# For example, let's say that you want to compare strains C7P and H7P, then you will do this:
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
metadata_temp <- metadata %>%
dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
View(metadata_temp)
# First of all, make sure you get a version of the protein matrix and of the metadata which contain only the samples that you want to analyze
# For example, let's say that you want to compare strains C7P and H7P, then you will do this:
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
#metadata_temp <- metadata %>%
#  dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
#protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# Now, the next step is making sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata_temp[match(colnames(protein_mat_temp), metadata$Sample.Name), ]
# Create a design matrix - this is the matrix that tells the DE algorithm which samples belong to the same group. This grouping is based on the variable you specify after the ~ symbol. So, in case you want to do this by strain, for example, you would specify "Strain.Type", and in case you want to do it for each of the possible treatment+strain+passage combinations, you would specify "Strain.Name" (this is what we are going with here, since we are comparing C7P and H7P).
design <- model.matrix(~ Strain.Name, data = metadata_sorted)
View(metadata_sorted)
# First of all, make sure you get a version of the protein matrix and of the metadata which contain only the samples that you want to analyze
# For example, let's say that you want to compare strains C7P and H7P, then you will do this:
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
#metadata_temp <- metadata %>%
#  dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
#protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# Now, the next step is making sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata_temp[match(colnames(protein_mat_temp), metadata_temp$Sample.Name), ]
# Create a design matrix - this is the matrix that tells the DE algorithm which samples belong to the same group. This grouping is based on the variable you specify after the ~ symbol. So, in case you want to do this by strain, for example, you would specify "Strain.Type", and in case you want to do it for each of the possible treatment+strain+passage combinations, you would specify "Strain.Name" (this is what we are going with here, since we are comparing C7P and H7P).
design <- model.matrix(~ Strain.Name, data = metadata_sorted)
# Fit model
fit <- lmFit(protein_mat_temp, design)
fit <- eBayes(fit)
# Extract results for the corresponding coefficient of the fitted model
da_results <- topTable(fit, coef = "Strain.Name", number = Inf, adjust.method = "BH")
View(fit)
# Extract results for the corresponding coefficient of the fitted model
da_results <- topTable(fit, number = Inf, adjust.method = "BH")
View(da_results)
ggplot(data = da_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +      # this adds the horizontal line at p-value = 0.05
labs(title = glue("Differentially abundant proteins for {name}")) +          # this creates the plot title
geom_vline(xintercept = mean(df$logFC)+2*sd(df$logFC), col = "orange", linewidth = 1) + # this line and the following create the vertical lines, for a logFC threshold
geom_vline(xintercept = mean(df$logFC)-2*sd(df$logFC), col = "orange", linewidth = 1)   # since this threshold would be different across these plots, I set it at the +-2*SD of the logFC distribution
ggplot(data = da_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +      # this adds the horizontal line at p-value = 0.05
labs(title = glue("Differentially abundant proteins for {name}")) +          # this creates the plot title
geom_vline(xintercept = mean(da_results$logFC)+2*sd(da_results$logFC), col = "orange", linewidth = 1) + # this line and the following create the vertical lines, for a logFC threshold
geom_vline(xintercept = mean(da_results$logFC)-2*sd(da_results$logFC), col = "orange", linewidth = 1)   # since this threshold would be different across these plots, I set it at the +-2*SD of the logFC distribution
View(design)
ggplot(data = da_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +      # this adds the horizontal line at p-value = 0.05
labs(title = glue("Differentially abundant proteins for H7P vs. C7P")) +          # this creates the plot title
geom_vline(xintercept = 1, col = "orange", linewidth = 1) + # this line and the following create the vertical lines, for a logFC threshold
geom_vline(xintercept = -1, col = "orange", linewidth = 1)   # since this threshold would be different across these plots, I set it at the +-2*SD of the logFC distribution
# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/uniprotkb_proteome_UP000000559_2025_10_19.tsv"))
# Get the corresponding KEGG IDs to the UniProt gene names, since the GSEA is performed in terms of the KEGG IDs
temp_entrez <- entrez_db %>%
dplyr::select(Entry, GeneID) %>%
dplyr::rename(uniprot = Entry) %>%
dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))
# Process .gmt file to turn it into the list of gene set vectors we need for gsea()
gmt <- read.gmt("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt")
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect
proteins_detected <- temp_entrez$GeneID
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)
kegg_genes <- lapply(names(gmt), function(pathway) {
intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
View(da_results)
# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/uniprotkb_proteome_UP000000559_2025_10_19.tsv"))
# Get the corresponding KEGG IDs to the UniProt gene names, since the GSEA is performed in terms of the KEGG IDs
temp_entrez <- entrez_db %>%
dplyr::select(Entry, GeneID) %>%
dplyr::rename(uniprot = Entry) %>%
dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))
# Process .gmt file to turn it into the list of gene set vectors we need for gsea()
gmt <- read.gmt("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt")
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect
proteins_detected <- temp_entrez$GeneID
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)
kegg_genes <- lapply(names(gmt), function(pathway) {
intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
# Rename the column with the protein names so that we can match with the UniProt dataset modified above
da_results <- da_results %>%
dplyr::rename(uniprot = protein) %>%
left_join(temp_entrez, by = "uniprot")
# First of all, make sure you get a version of the protein matrix and of the metadata which contain only the samples that you want to analyze
# For example, let's say that you want to compare strains C7P and H7P, then you will do this:
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
#metadata_temp <- metadata %>%
#  dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
#protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# Now, the next step is making sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata_temp[match(colnames(protein_mat_temp), metadata_temp$Sample.Name), ]
# It's important that you realize that the differential abundance analysis is done based on a certain column of the metadata file. This is, if we want to compare C7P vs. H7P, these are in the Strain.Name column in the metadata, so that is the one we will be using. If we wanted to compare all samples from the Lab strain to all samples from the Heteroresistant strain, we would be using the column Strain.Type, which is the one that contains this information. This columns is used to create the design matrix, which is the one that tells lmFit() which samples belong to which group.
# Next, make sure that the reference strain is the one you want. This is crucial for proper interpretation: upregulated or downregulated proteins will be upregulated or downregulated in the other strain, with respect to the reference one. Here we defined C7P as the reference one, since it's the lab strain.
metadata_sorted$Strain.Name <- relevel(metadata_sorted$Strain.Name,
ref = "C7P")
# First of all, make sure you get a version of the protein matrix and of the metadata which contain only the samples that you want to analyze
# For example, let's say that you want to compare strains C7P and H7P, then you will do this:
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
#metadata_temp <- metadata %>%
#  dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
#protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# Now, the next step is making sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata_temp[match(colnames(protein_mat_temp), metadata_temp$Sample.Name), ]
# It's important that you realize that the differential abundance analysis is done based on a certain column of the metadata file. This is, if we want to compare C7P vs. H7P, these are in the Strain.Name column in the metadata, so that is the one we will be using. If we wanted to compare all samples from the Lab strain to all samples from the Heteroresistant strain, we would be using the column Strain.Type, which is the one that contains this information. This columns is used to create the design matrix, which is the one that tells lmFit() which samples belong to which group.
# Next, make sure that the reference strain is the one you want. This is crucial for proper interpretation: upregulated or downregulated proteins will be upregulated or downregulated in the other strain, with respect to the reference one. Here we defined C7P as the reference one, since it's the lab strain.
metadata_sorted$Strain.Name <- as.factor(metadata_sorted$Strain.Name)
metadata_sorted$Strain.Name <- relevel(metadata_sorted$Strain.Name,
ref = "C7P")
# Create a design matrix - this is the matrix that tells the DE algorithm which samples belong to the same group. This grouping is based on the variable you specify after the ~ symbol. So, this corresponds to the name of the column in the metadata that contains the information we are working with, as I explain 2 paragraphs above.
design <- model.matrix(~ Strain.Name, data = metadata_sorted)
# Fit model
fit <- lmFit(protein_mat_temp, design)
fit <- eBayes(fit)
# Extract results for the corresponding coefficient of the fitted model
da_results <- topTable(fit, number = Inf, adjust.method = "BH")
# The protein IDs are in the rownames now, let's put them in a column instead
da_results <- tibble::rownames_to_column(da_results, var = "protein")
# This result dataframe contains the logFC and the adjusted p-value for each protein, for the comparison of the abundance of this protein between the 2 specified groups - this is all you need to create a volcano plot.
# Something that is quite annoying but that is important to keep in mind, is multiple testing correction. I recommend you look into the concept, since it's really important to be aware of, but basically the idea is that when you do many statistical tests at once (that is basically what we are doing here, one test for each protein, comparing it across the 2 groups), there is the probability that some of this tests provide significant results just by pure chance, without a real biological difference existing. Hence, multiple testing correction is done to be safe from this. This can be done in different ways, but the most common one for high-dimensional data (proteomics, transcriptomics, etc.) is FDR, or BH (Benjamini-Hochberg). This is done by the "adjust.method = "BH"" in the "topTable()" function. HOWEVER, I want to make sure you understand that if you do this for many pairs of strains separately, you are only correcting for multiple testing within each comparison, not taking into account all the tests you are making in all other comparisons. This is not optimal, the optimal idea would be to join the results from each of the pairwise comparisons and perform a multiple testing correction (a.k.a. p-value adjustment btw) for all of them together, and then separate them again for volcano plots and so on.
ggplot(data = da_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +      # this adds the horizontal line at p-value = 0.05
labs(title = glue("Differentially abundant proteins for H7P vs. C7P")) +          # this creates the plot title
geom_vline(xintercept = 1, col = "orange", linewidth = 1) +   # this line and the following create the vertical lines, for a logFC threshold
geom_vline(xintercept = -1, col = "orange", linewidth = 1)   # the logFC threhsold is pretty ad-hoc, I use 1 here as an example but this is not a fixed threshold like the p-value one, it can change in different datasets
# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/uniprotkb_proteome_UP000000559_2025_10_19.tsv"))
# Get the corresponding KEGG IDs to the UniProt gene names, since the GSEA is performed in terms of the KEGG IDs
temp_entrez <- entrez_db %>%
dplyr::select(Entry, GeneID) %>%
dplyr::rename(uniprot = Entry) %>%
dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))
# Process .gmt file to turn it into the list of gene set vectors we need for gsea()
gmt <- read.gmt("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt")
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect
proteins_detected <- temp_entrez$GeneID
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)
kegg_genes <- lapply(names(gmt), function(pathway) {
intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
# Rename the column with the protein names so that we can match with the UniProt dataset modified above
da_results <- da_results %>%
dplyr::rename(uniprot = protein) %>%
left_join(temp_entrez, by = "uniprot")
# Using as score the [-log10(p-value)*sign of the logFC], calculate this for every row in the dataset - this is, for every protein
# This score contains the information from both the p-value and the logFC - there are many different ones that can be used, but this is a kind of standard one
rankings <- sign(da_results$logFC)*(-log10(da_results$adj.P.Val))
names(rankings) <- da_results$GeneID
rankings <- sort(rankings, decreasing = TRUE)
# Sometimes, some genes have such low p-values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(rankings[is.finite(rankings)])
min_ranking <- min(rankings[is.finite(rankings)])
rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
rankings <- sort(rankings, decreasing = TRUE)                                   # sort genes by ranking
# Get rid of rankings with emtpy names and with repeated names
length(rankings)
rankings <- rankings[!is.na(names(rankings)) & names(rankings) != ""]
rankings <- rankings[!duplicated(names(rankings))]
length(rankings)
# Run GSEA
fgseaRes <- fgsea(
pathways = kegg_genes,
stats = rankings,
minSize = 10,
maxSize = 500)
# Create a new column which marks each patwhay as up- or down-regulated based on the sign of the NES (this is kind of the equivalent of the logFC in the DEA)
# Also modify the name of the pathway, remove the ugly stuff at the beginning and substitute "_" for " ".
fgseaRes <- fgseaRes %>%
dplyr::mutate(direction = case_when(NES > 0 ~ "Up-regulated",
NES < 0 ~ "Down-regulated",
TRUE    ~ "Neutral")) %>%
dplyr::mutate(pathway = str_replace_all(str_remove(pathway, "^[^_]*_"), "_", " "))
# Grab the top pathways, filtering based on their p-values - BE CAREFUL!: we are not filtering based on NES (kind of effect size), so need to keep an eye on that, it could be that we have significant p-values but the NES is so small that it is not biologically relevant
top_pathways <- fgseaRes %>%
dplyr::filter(padj < alpha_enrichment) %>%
arrange(padj)
# Create the barplot
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +             #fct_reorder() orders the bars based on NES
geom_col() +
coord_flip() +                                                                                  # horizontal bars instead of vertical
scale_fill_manual(values = c("Up-regulated" = "firebrick", "Down-regulated" = "steelblue")) +
labs(x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = glue("Top enriched pathways for {name}")) +
theme_minimal(base_size = 11) +
theme(plot.title = element_text(size = 13))                                                     # set smaller title font here
# One last check before doing the differential abundance analysis: if there are any proteins which are not detected in any of the samples of either of the groups we are comparing, we need to get rid of them (and save them elsewhere so that we can check them later if we want). This is because if we try to do the statistical testing between the two groups in such a protein, where there are no values measured for that protein at all in one of the groups, the statistical test breaks down and we get insane logFC values which are not interpretable.
# I iterate over the proteins (the rows) and for each of them, separate the samples for one treatment and for the other, and check if either of these groups is composed solely of NAs. If so, I mark this protein to be removed.
strains <- levels(metadata_sorted$Strain.Name)
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
#metadata_temp <- metadata %>%
#  dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
#protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# Now, the next step is making sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata_temp[match(colnames(protein_mat_temp), metadata_temp$Sample.Name), ]
# It's important that you realize that the differential abundance analysis is done based on a certain column of the metadata file. This is, if we want to compare C7P vs. H7P, these are in the Strain.Name column in the metadata, so that is the one we will be using. If we wanted to compare all samples from the Lab strain to all samples from the Heteroresistant strain, we would be using the column Strain.Type, which is the one that contains this information. This columns is used to create the design matrix, which is the one that tells lmFit() which samples belong to which group.
# Next, make sure that the reference strain is the one you want. This is crucial for proper interpretation: upregulated or downregulated proteins will be upregulated or downregulated in the other strain, with respect to the reference one. Here we defined C7P as the reference one, since it's the lab strain.
metadata_sorted$Strain.Name <- as.factor(metadata_sorted$Strain.Name)
metadata_sorted$Strain.Name <- relevel(metadata_sorted$Strain.Name,
ref = "C7P")
strains <- levels(metadata_sorted$Strain.Name)
proteins_to_be_removed <- c()
for (i in 1:nrows(protein_mat_temp)) {
this_protein <- rownames(protein_mat_temp)[i]
values_in_one_strain <- as.numeric(protein_mat_temp[i, grepl(strains[1], colnames(protein_mat_temp))])
values_in_the_other_strain <- as.numeric(protein_mat_temp[i, grepl(strains[2], colnames(protein_mat_temp))])
if (sum(is.na(values_in_one_strain)) == length(values_in_one_strain) | sum(is.na(values_in_the_other_strain)) == length(values_in_the_other_strain)) {
proteins_to_be_removed <- c(proteins_to_be_removed, this_protein)
}
}
strains <- levels(metadata_sorted$Strain.Name)
proteins_to_be_removed <- c()
for (i in 1:nrow(protein_mat_temp)) {
this_protein <- rownames(protein_mat_temp)[i]
values_in_one_strain <- as.numeric(protein_mat_temp[i, grepl(strains[1], colnames(protein_mat_temp))])
values_in_the_other_strain <- as.numeric(protein_mat_temp[i, grepl(strains[2], colnames(protein_mat_temp))])
if (sum(is.na(values_in_one_strain)) == length(values_in_one_strain) | sum(is.na(values_in_the_other_strain)) == length(values_in_the_other_strain)) {
proteins_to_be_removed <- c(proteins_to_be_removed, this_protein)
}
}
# Remove these proteins from the main dataset and put them into another, separate dataset, in case we want to look at them later
removed_proteins <- protein_mat_temp[rownames(protein_mat_temp) %in% proteins_to_be_removed]
# Remove these proteins from the main dataset and put them into another, separate dataset, in case we want to look at them later
removed_proteins <- protein_mat_temp[rownames(protein_mat_temp) %in% proteins_to_be_removed,]
View(removed_proteins)
# The first thing we do though, is to remove any proteins which are not detected in any of the samples, of any of the strains we are looking at here.
all_nas <- apply(protein_mat_temp, 1, function(x) sum(is.na(x))/ncol(protein_mat_temp))
sum(all_nas)
# The first thing we do though, is to remove any proteins which are not detected in any of the samples, of any of the strains we are looking at here.
all_nas <- apply(protein_mat_temp, 1, function(x) sum(is.na(x))/ncol(protein_mat_temp) == 1)
sum(all_nas)
check <- protein_mat_temp[all_nas,]
View(check)
protein_mat_temp <- protein_mat_temp[!all_nas,]
strains <- levels(metadata_sorted$Strain.Name)
proteins_to_be_removed <- c()
for (i in 1:nrow(protein_mat_temp)) {
this_protein <- rownames(protein_mat_temp)[i]
values_in_one_strain <- as.numeric(protein_mat_temp[i, grepl(strains[1], colnames(protein_mat_temp))])
values_in_the_other_strain <- as.numeric(protein_mat_temp[i, grepl(strains[2], colnames(protein_mat_temp))])
if (sum(is.na(values_in_one_strain)) == length(values_in_one_strain) | sum(is.na(values_in_the_other_strain)) == length(values_in_the_other_strain)) {
proteins_to_be_removed <- c(proteins_to_be_removed, this_protein)
}
}
# Remove these proteins from the main dataset and put them into another, separate dataset, in case we want to look at them later
removed_proteins <- protein_mat_temp[rownames(protein_mat_temp) %in% proteins_to_be_removed,]
View(removed_proteins)
metadata_temp <- metadata %>%
dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
#metadata_temp <- metadata %>%
#  dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
#protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]
# This is not necessary, but I like to order the columns alphabetically so that all the samples of each group are together
protein_mat_temp <- protein_mat_temp %>%
dplyr::select(order(colnames(protein_mat_temp)))
# Now, the next step is making sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata_temp[match(colnames(protein_mat_temp), metadata_temp$Sample.Name), ]
# It's important that you realize that the differential abundance analysis is done based on a certain column of the metadata file. This is, if we want to compare C7P vs. H7P, these are in the Strain.Name column in the metadata, so that is the one we will be using. If we wanted to compare all samples from the Lab strain to all samples from the Heteroresistant strain, we would be using the column Strain.Type, which is the one that contains this information. This columns is used to create the design matrix, which is the one that tells lmFit() which samples belong to which group.
# Next, make sure that the reference strain is the one you want. This is crucial for proper interpretation: upregulated or downregulated proteins will be upregulated or downregulated in the other strain, with respect to the reference one. Here we defined C7P as the reference one, since it's the lab strain.
metadata_sorted$Strain.Name <- as.factor(metadata_sorted$Strain.Name)
metadata_sorted$Strain.Name <- relevel(metadata_sorted$Strain.Name,
ref = "C7P")
# One last check before doing the differential abundance analysis: if there are any proteins which are not detected in any of the samples of either of the groups we are comparing, we need to get rid of them (and save them elsewhere so that we can check them later if we want). This is because if we try to do the statistical testing between the two groups in such a protein, where there are no values measured for that protein at all in one of the groups, the statistical test breaks down and we get insane logFC values which are not interpretable.
# The first thing we do though, is to remove any proteins which are not detected in any of the samples, of any of the strains we are looking at here.
all_nas <- apply(protein_mat_temp, 1, function(x) sum(is.na(x))/ncol(protein_mat_temp) == 1)
protein_mat_temp <- protein_mat_temp[!all_nas,]
# I iterate over the proteins (the rows) and for each of them, separate the samples for one treatment and for the other, and check if either of these groups is composed solely of NAs. If so, I mark this protein to be removed, by saving it to the vector called "proteins_to_be_removed".
strains <- levels(metadata_sorted$Strain.Name)
proteins_to_be_removed <- c()
for (i in 1:nrow(protein_mat_temp)) {
this_protein <- rownames(protein_mat_temp)[i]
values_in_one_strain <- as.numeric(protein_mat_temp[i, grepl(strains[1], colnames(protein_mat_temp))])
values_in_the_other_strain <- as.numeric(protein_mat_temp[i, grepl(strains[2], colnames(protein_mat_temp))])
if (sum(is.na(values_in_one_strain)) == length(values_in_one_strain) | sum(is.na(values_in_the_other_strain)) == length(values_in_the_other_strain)) {
proteins_to_be_removed <- c(proteins_to_be_removed, this_protein)
}
}
# Remove these proteins from the main dataset and put them into another, separate dataset, in case we want to look at them later
removed_proteins <- protein_mat_temp[rownames(protein_mat_temp) %in% proteins_to_be_removed,]
View(removed_proteins)
protein_mat_temp <- protein_mat_temp[!rownames(protein_mat_temp) %in% proteins_to_be_removed,]
design <- model.matrix(~ Strain.Name, data = metadata_sorted)
# Fit model
fit <- lmFit(protein_mat_temp, design)
fit <- eBayes(fit)
# Extract results for the corresponding coefficient of the fitted model
da_results <- topTable(fit, number = Inf, adjust.method = "BH")
# The protein IDs are in the rownames now, let's put them in a column instead
da_results <- tibble::rownames_to_column(da_results, var = "protein")
ggplot(data = da_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +      # this adds the horizontal line at p-value = 0.05
labs(title = glue("Differentially abundant proteins for H7P vs. C7P")) +          # this creates the plot title
geom_vline(xintercept = 1, col = "orange", linewidth = 1) +   # this line and the following create the vertical lines, for a logFC threshold
geom_vline(xintercept = -1, col = "orange", linewidth = 1)   # the logFC threhsold is pretty ad-hoc, I use 1 here as an example but this is not a fixed threshold like the p-value one, it can change in different datasets
# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/uniprotkb_proteome_UP000000559_2025_10_19.tsv"))
# Get the corresponding KEGG IDs to the UniProt gene names, since the GSEA is performed in terms of the KEGG IDs
temp_entrez <- entrez_db %>%
dplyr::select(Entry, GeneID) %>%
dplyr::rename(uniprot = Entry) %>%
dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))
# Process .gmt file to turn it into the list of gene set vectors we need for gsea()
gmt <- read.gmt("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt")
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect
proteins_detected <- temp_entrez$GeneID
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)
kegg_genes <- lapply(names(gmt), function(pathway) {
intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
# Rename the column with the protein names so that we can match with the UniProt dataset modified above
da_results <- da_results %>%
dplyr::rename(uniprot = protein) %>%
left_join(temp_entrez, by = "uniprot")
# Using as score the [-log10(p-value)*sign of the logFC], calculate this for every row in the dataset - this is, for every protein
# This score contains the information from both the p-value and the logFC - there are many different ones that can be used, but this is a kind of standard one
rankings <- sign(da_results$logFC)*(-log10(da_results$adj.P.Val))
names(rankings) <- da_results$GeneID
rankings <- sort(rankings, decreasing = TRUE)
# Sometimes, some genes have such low p-values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(rankings[is.finite(rankings)])
min_ranking <- min(rankings[is.finite(rankings)])
rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
rankings <- sort(rankings, decreasing = TRUE)                                   # sort genes by ranking
# Get rid of rankings with emtpy names and with repeated names
length(rankings)
rankings <- rankings[!is.na(names(rankings)) & names(rankings) != ""]
rankings <- rankings[!duplicated(names(rankings))]
length(rankings)
# Run GSEA
fgseaRes <- fgsea(
pathways = kegg_genes,
stats = rankings,
minSize = 10,
maxSize = 500)
# Create a new column which marks each patwhay as up- or down-regulated based on the sign of the NES (this is kind of the equivalent of the logFC in the DEA)
# Also modify the name of the pathway, remove the ugly stuff at the beginning and substitute "_" for " ".
fgseaRes <- fgseaRes %>%
dplyr::mutate(direction = case_when(NES > 0 ~ "Up-regulated",
NES < 0 ~ "Down-regulated",
TRUE    ~ "Neutral")) %>%
dplyr::mutate(pathway = str_replace_all(str_remove(pathway, "^[^_]*_"), "_", " "))
# Grab the top pathways, filtering based on their p-values - BE CAREFUL!: we are not filtering based on NES (kind of effect size), so need to keep an eye on that, it could be that we have significant p-values but the NES is so small that it is not biologically relevant
top_pathways <- fgseaRes %>%
dplyr::filter(padj < alpha_enrichment) %>%
arrange(padj)
# Create the barplot
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +             #fct_reorder() orders the bars based on NES
geom_col() +
coord_flip() +                                                                                  # horizontal bars instead of vertical
scale_fill_manual(values = c("Up-regulated" = "firebrick", "Down-regulated" = "steelblue")) +
labs(x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = glue("Top enriched pathways for H7P vs. C7P")) +
theme_minimal(base_size = 11) +
theme(plot.title = element_text(size = 13))                                                     # set smaller title font here
