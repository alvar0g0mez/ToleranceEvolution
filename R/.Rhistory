dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))
View(temp_entrez)
raw_data <- protein_mat[, !grepl("QC", colnames(protein_mat))]
# Make sure column order matches
metadata <- metadata[match(colnames(raw_data), metadata$Sample.Name), ]
# Design matrix
design <- model.matrix(~ FoG20 + Treatment + Strain.Type, data = metadata)
colnames(design)
# The first column (Intercept) is baseline expression
# The second column (FoG20) is your variable of interest
# Fit model
fit <- lmFit(raw_data, design)
fit <- eBayes(fit)
# Extract results for the 'FoG20' coefficient
FoG20_results <- topTable(fit, coef = "FoG20", number = Inf, adjust.method = "BH")
# Add protein IDs
FoG20_results <- tibble::rownames_to_column(FoG20_results, var = "protein")
# Classify as up/down associated
FoG20_results <- FoG20_results %>%
mutate(
diffexpressed_adjusted = case_when(
(logFC > 0 & adj.P.Val < 0.05) ~ "Positively_correlated_with_FoG20",
(logFC < 0 & adj.P.Val < 0.05) ~ "Negatively_correlated_with_FoG20",
TRUE ~ "Not_significant"
)
)
# Quick summary
table(FoG20_results$diffexpressed_adjusted)
# Volcano plot
ggplot(data = FoG20_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
geom_vline(xintercept = 0.05, col = "orange", linewidth = 1) +
geom_vline(xintercept = -0.05, col = "orange", linewidth = 1)
# Correlation heatmap
## Select top positively and negatively correlated proteins
top_pos <- FoG20_results %>%
arrange(desc(logFC)) %>%
slice_head(n = 15) %>%
pull(protein)
top_neg <- FoG20_results %>%
arrange(logFC) %>%
slice_head(n = 15) %>%
pull(protein)
top_proteins <- c(top_pos, top_neg)
## Subset expression matrix
expr_subset <- raw_data[top_proteins, ]
## Optionally order samples by FoG20 level
sample_order <- order(metadata$FoG20)
expr_subset <- expr_subset[, sample_order]
annotation_col <- metadata[sample_order, c("FoG20", "Treatment")]
## Plot heatmap
# --- Step 1: Z-score (row-scale) the expression matrix manually
expr_scaled <- t(scale(t(expr_subset)))  # same as pheatmap(scale="row")
# --- Step 2: Prepare column annotations
# Convert annotation_col to a HeatmapAnnotation object
# You can specify colors if you like, or let ComplexHeatmap choose automatically
ha_col <- HeatmapAnnotation(
df = annotation_col,
col = list(
Treatment = structure(
RColorBrewer::brewer.pal(length(unique(annotation_col$Treatment)), "Set2"),
names = unique(annotation_col$Treatment)
),
# Optional: color scale for numeric variables
FoG20 = colorRamp2(
c(min(annotation_col$FoG20), max(annotation_col$FoG20)),
c("blue", "red")
)
),
annotation_height = unit(0.8, "cm")
)
# --- Step 3: Draw the heatmap
Heatmap(
expr_scaled,
name = "Z-score",
top_annotation = ha_col,
show_row_names = TRUE,
show_column_names = FALSE,
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_method_rows = "complete",
clustering_method_columns = "complete",
column_title = "Top proteins correlated with FoG20",
row_title = "Proteins",
heatmap_legend_param = list(title = "Expression (Z)")
)
View(FoG20_results)
FoG20_results <- FoG20_results %>%
dplyr::rename(uniprot = protein) %>%
left_join(temp_entrez, by = "uniprot")
# Get the corresponding KEGG IDs to these UniProt gene names, since the GSEA is performed in terms of those
temp_entrez <- entrez_db %>%
dplyr::select(Entry, GeneID) %>%
dplyr::rename(uniprot = Entry) %>%
dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))
FoG20_results <- FoG20_results %>%
dplyr::rename(uniprot = protein) %>%
left_join(temp_entrez, by = "uniprot")
raw_data <- protein_mat[, !grepl("QC", colnames(protein_mat))]
# Make sure column order matches
metadata <- metadata[match(colnames(raw_data), metadata$Sample.Name), ]
# Design matrix
design <- model.matrix(~ FoG20 + Treatment + Strain.Type, data = metadata)
colnames(design)
# The first column (Intercept) is baseline expression
# The second column (FoG20) is your variable of interest
# Fit model
fit <- lmFit(raw_data, design)
fit <- eBayes(fit)
# Extract results for the 'FoG20' coefficient
FoG20_results <- topTable(fit, coef = "FoG20", number = Inf, adjust.method = "BH")
# Add protein IDs
FoG20_results <- tibble::rownames_to_column(FoG20_results, var = "protein")
# Classify as up/down associated
FoG20_results <- FoG20_results %>%
mutate(
diffexpressed_adjusted = case_when(
(logFC > 0 & adj.P.Val < 0.05) ~ "Positively_correlated_with_FoG20",
(logFC < 0 & adj.P.Val < 0.05) ~ "Negatively_correlated_with_FoG20",
TRUE ~ "Not_significant"
)
)
# Quick summary
table(FoG20_results$diffexpressed_adjusted)
# Volcano plot
ggplot(data = FoG20_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
geom_vline(xintercept = 0.05, col = "orange", linewidth = 1) +
geom_vline(xintercept = -0.05, col = "orange", linewidth = 1)
# Correlation heatmap
## Select top positively and negatively correlated proteins
top_pos <- FoG20_results %>%
arrange(desc(logFC)) %>%
slice_head(n = 15) %>%
pull(protein)
top_neg <- FoG20_results %>%
arrange(logFC) %>%
slice_head(n = 15) %>%
pull(protein)
top_proteins <- c(top_pos, top_neg)
## Subset expression matrix
expr_subset <- raw_data[top_proteins, ]
## Optionally order samples by FoG20 level
sample_order <- order(metadata$FoG20)
expr_subset <- expr_subset[, sample_order]
annotation_col <- metadata[sample_order, c("FoG20", "Treatment")]
## Plot heatmap
# --- Step 1: Z-score (row-scale) the expression matrix manually
expr_scaled <- t(scale(t(expr_subset)))  # same as pheatmap(scale="row")
# --- Step 2: Prepare column annotations
# Convert annotation_col to a HeatmapAnnotation object
# You can specify colors if you like, or let ComplexHeatmap choose automatically
ha_col <- HeatmapAnnotation(
df = annotation_col,
col = list(
Treatment = structure(
RColorBrewer::brewer.pal(length(unique(annotation_col$Treatment)), "Set2"),
names = unique(annotation_col$Treatment)
),
# Optional: color scale for numeric variables
FoG20 = colorRamp2(
c(min(annotation_col$FoG20), max(annotation_col$FoG20)),
c("blue", "red")
)
),
annotation_height = unit(0.8, "cm")
)
# --- Step 3: Draw the heatmap
Heatmap(
expr_scaled,
name = "Z-score",
top_annotation = ha_col,
show_row_names = TRUE,
show_column_names = FALSE,
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_method_rows = "complete",
clustering_method_columns = "complete",
column_title = "Top proteins correlated with FoG20",
row_title = "Proteins",
heatmap_legend_param = list(title = "Expression (Z)")
)
# Get the corresponding KEGG IDs to these UniProt gene names, since the GSEA is performed in terms of those
temp_entrez <- entrez_db %>%
dplyr::select(Entry, GeneID) %>%
dplyr::rename(uniprot = Entry) %>%
dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))
FoG20_results <- FoG20_results %>%
dplyr::rename(uniprot = protein) %>%
left_join(temp_entrez, by = "uniprot")
# Using as score the -log10(p-value)*sign of the logFC
rankings <- sign(FoG20_results$logFC)*(-log10(FoG20_results$adj.P.Val))
names(rankings) <- FoG20_results$GeneID
rankings <- sort(rankings, decreasing = TRUE)
# Plot
plot(rankings)
# Check max and min - to see if there is a need to correct for -Inf and +Inf - commented out, I don't think it's necessary
#print(max(rankings))
#print(min(rankings))
# Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
# (this part is copy pasted from the link)
max_ranking <- max(rankings[is.finite(rankings)])
min_ranking <- min(rankings[is.finite(rankings)])
rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
rankings <- sort(rankings, decreasing = TRUE)                                   # sort genes by ranking
# Save this ranked lists so that I can use them later to pick the top 50 proteins in each strain, to look at the overlaps between major strains within families in a more unbiased manner - not really feasible for now since the distribution of the scores for the vast majority of strains is pretty much flat. I wonder how much this affects my DEA?
#write_json(ranked_genes, path = paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/lists_of_ranked_genes_", alpha_plain, "_logFC_", as.character(lfc_threshold), sep=""), pretty = T)
library(qusage)
gmt <- read.gmt(paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt", sep=""))
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect - now we already have it! It's mapping_df$kegg_gene :)
proteins_detected <- mapping_df$GeneID
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)
kegg_genes <- lapply(names(gmt), function(pathway) {
intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
View(kegg_genes)
View(gmt)
proteins_detected
gmt <- read.gmt(paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt", sep=""))
gmt$term <- as.character(gmt$term)
# Get a simple vector with the Entrez IDs of the proteins we detect - now we already have it! It's temp_entrez$GeneID :)
proteins_detected <- temp_entrez$GeneID
# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)
kegg_genes <- lapply(names(gmt), function(pathway) {
intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
View(kegg_genes)
fgseaRes <- fgsea(
pathways = kegg_genes,
stats = rankings,
minSize = 10,
maxSize = 500,
nperm = 10000)
library(fgsea)
fgseaRes <- fgsea(
pathways = kegg_genes,
stats = rankings,
minSize = 10,
maxSize = 500,
nperm = 10000)
fgseaRes <- fgsea(
pathways = kegg_genes,
stats = rankings,
minSize = 10,
maxSize = 500)
names(rankings)
# Get rid of rankings with emtpy names and with repeated names
length(rankings)
rankings <- rankings[!is.na(names(rankings)) & names(rankings) != ""]
rankings <- rankings[!duplicated(names(rankings))]
length(rankings)
fgseaRes <- fgsea(
pathways = kegg_genes,
stats = rankings,
minSize = 10,
maxSize = 500)
View(fgseaRes)
# Save these results
write_json(fgseaRes, paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/kegg_gsea_results_tolerance_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), pretty = T)
# Save these results
fwrite(fgseaRes, paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/kegg_gsea_results_tolerance_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".tsv", sep=""))
fgseaRes <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/kegg_gsea_results_tolerance_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".tsv", sep="")))
ggplot(data = fgseaRes, aes(x = NES, y = -log10(padj))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
theme_light()
ggplot(data = fgseaRes, aes(x = NES, y = -log10(padj))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
theme_light() +
xlab("Normalized Enrichment Score")
ggplot(data = fgseaRes, aes(x = NES, y = -log10(padj))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
theme_light() +
xlab("Normalized Enrichment Score") +
ylab("-log10(Adjusted p-value)")
library(ggrepel)
ggplot(data = fgseaRes, aes(x = NES, y = -log10(padj))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
theme_light() +
xlab("Normalized Enrichment Score") +
ylab("-log10(Adjusted p-value)") +
labs(title = "KEGG pathways enriched with respect to tolerance") +
geom_label_repel(subset(fgseaRes, NES > 1.5 & -log10(padj) > -log10(0.05)),
aes(x = NES, y = -log10(padj), label = pathway))
ggplot(data = fgseaRes, aes(x = NES, y = -log10(padj))) +
geom_point() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
theme_light() +
xlab("Normalized Enrichment Score") +
ylab("-log10(Adjusted p-value)") +
labs(title = "KEGG pathways enriched with respect to tolerance") +
geom_label_repel(data = subset(fgseaRes, NES > 1.5 & -log10(padj) > -log10(0.05)),
aes(x = NES, y = -log10(padj), label = pathway))
raw_data <- protein_mat[, !grepl("QC", colnames(protein_mat))]
# Make sure column order matches
metadata <- metadata[match(colnames(raw_data), metadata$Sample.Name), ] %>%
dplyr::mutate(Resistance = -RAD20)
# Design matrix
design <- model.matrix(~ Resistance + Treatment + Strain.Type, data = metadata)
colnames(design)
# The first column (Intercept) is baseline expression
# The second column (Resistance) is your variable of interest
# Fit model
fit <- lmFit(raw_data, design)
fit <- eBayes(fit)
# Extract results for the 'Resistance' coefficient
resistance_results <- topTable(fit, coef = "Resistance", number = Inf, adjust.method = "BH")
# Add protein IDs
resistance_results <- tibble::rownames_to_column(resistance_results, var = "protein")
# Classify as up/down associated
resistance_results <- resistance_results %>%
mutate(
diffexpressed_adjusted = case_when(
(logFC > 0 & adj.P.Val < 0.05) ~ "Positively_correlated_with_resistance",
(logFC < 0 & adj.P.Val < 0.05) ~ "Negatively_correlated_with_resistance",
TRUE ~ "Not_significant"
)
)
# Quick summary
table(resistance_results$diffexpressed_adjusted)
# Volcano plot
ggplot(data = resistance_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1)
#geom_vline(xintercept = 0.0075, col = "orange", linewidth = 1) +
#geom_vline(xintercept = -0.0075, col = "orange", linewidth = 1)
# Correlation heatmap
## Select top positively and negatively correlated proteins
top_pos <- resistance_results %>%
arrange(desc(logFC)) %>%
slice_head(n = 15) %>%
pull(protein)
top_neg <- resistance_results %>%
arrange(logFC) %>%
slice_head(n = 15) %>%
pull(protein)
top_proteins <- c(top_pos, top_neg)
## Subset expression matrix
expr_subset <- raw_data[top_proteins, ]
## Optionally order samples by Resistance level
sample_order <- order(metadata$RAD20)
expr_subset <- expr_subset[, sample_order]
annotation_col <- metadata[sample_order, c("Resistance", "Treatment")]
## Plot heatmap
# --- Step 1: Z-score (row-scale) the expression matrix manually
expr_scaled <- t(scale(t(expr_subset)))  # same as pheatmap(scale="row")
# --- Step 2: Prepare column annotations
# Convert annotation_col to a HeatmapAnnotation object
# You can specify colors if you like, or let ComplexHeatmap choose automatically
ha_col <- HeatmapAnnotation(
df = annotation_col,
col = list(
Treatment = structure(
RColorBrewer::brewer.pal(length(unique(annotation_col$Treatment)), "Set2"),
names = unique(annotation_col$Treatment)
),
# Optional: color scale for numeric variables
Resistance = colorRamp2(
c(min(annotation_col$Resistance), max(annotation_col$Resistance)),
c("blue", "red")
)
),
annotation_height = unit(0.8, "cm")
)
# --- Step 3: Draw the heatmap
Heatmap(
expr_scaled,
name = "Z-score",
top_annotation = ha_col,
show_row_names = TRUE,
show_column_names = FALSE,
cluster_rows = TRUE,
cluster_columns = TRUE,
clustering_method_rows = "complete",
clustering_method_columns = "complete",
column_title = "Top proteins correlated with resistance",
row_title = "Proteins",
heatmap_legend_param = list(title = "Expression (Z)")
)
# Volcano plot
ggplot(data = resistance_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
labs(title = "Differentially abundant genes with respect to resistance")
# Volcano plot
ggplot(data = FoG20_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
geom_vline(xintercept = 0.05, col = "orange", linewidth = 1) +
geom_vline(xintercept = -0.05, col = "orange", linewidth = 1) +
labs(title = "Differentially abundant proteins with respect to tolerance")
# Volcano plot
ggplot(data = resistance_results, aes(x = logFC, y = -log10(adj.P.Val))) +
geom_point() +
theme_light() +
geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +
labs(title = "Differentially abundant proteins with respect to resistance")
fgseaRes <- fgseaRes %>%
dplyr::mutate(direction = case_when(
NES > 0 ~ "Upregulated",
NES < 0 ~ "Downregulated",
TRUE    ~ "Neutral"))
top_pathways <- fgseaRes %>%
dplyr::filter(padj < 0.05)
top_pathways <- fgseaRes %>%
dplyr::filter(padj < 0.05) %>%
arrange(padj)
View(top_pathways)
fgseaRes <- fgseaRes %>%
dplyr::mutate(direction = case_when(
NES > 0 ~ "Upregulated",
NES < 0 ~ "Downregulated",
TRUE    ~ "Neutral")) %>%
dplyr::mutate(pathway = str_replace_all(str_remove(pathway, "^[^_]*_"), "_", " "))
top_pathways <- fgseaRes %>%
dplyr::filter(padj < 0.05) %>%
arrange(padj)
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
geom_col() +
coord_flip() +   # horizontal bars
scale_fill_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue")) +
labs(
x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = "Top enriched pathways with directionality"
) +
theme_minimal(base_size = 14)
library(forcats)
fgseaRes <- fgseaRes %>%
dplyr::mutate(direction = case_when(
NES > 0 ~ "Upregulated",
NES < 0 ~ "Downregulated",
TRUE    ~ "Neutral")) %>%
dplyr::mutate(pathway = str_replace_all(str_remove(pathway, "^[^_]*_"), "_", " "))
top_pathways <- fgseaRes %>%
dplyr::filter(padj < 0.05) %>%
arrange(padj)
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
geom_col() +
coord_flip() +   # horizontal bars
scale_fill_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue")) +
labs(
x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = "Top enriched pathways with directionality"
) +
theme_minimal(base_size = 14)
theme(plot.title = element_text(size = 12)  # set smaller title font here)
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
geom_col() +
coord_flip() +   # horizontal bars
scale_fill_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue")) +
labs(x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = "Top enriched pathways with respect to resistance") +
theme_minimal(base_size = 14) +
theme(plot.title = element_text(size = 12))  # set smaller title font here)
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
geom_col() +
coord_flip() +   # horizontal bars
scale_fill_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue")) +
labs(x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = "Top enriched pathways with respect to resistance") +
theme_minimal(base_size = 14) +
theme(plot.title = element_text(size = 14))  # set smaller title font here)
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
geom_col() +
coord_flip() +   # horizontal bars
scale_fill_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue")) +
labs(x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = "Top enriched pathways with respect to resistance") +
theme_minimal(base_size = 14) +
theme(plot.title = element_text(size = 13.5))  # set smaller title font here)
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
geom_col() +
coord_flip() +   # horizontal bars
scale_fill_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue")) +
labs(x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = "Top enriched pathways with respect to resistance") +
theme_minimal(base_size = 14) +
theme(plot.title = element_text(size = 13))  # set smaller title font here)
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +
geom_col() +
coord_flip() +   # horizontal bars
scale_fill_manual(values = c("Upregulated" = "firebrick", "Downregulated" = "steelblue")) +
labs(x = "Pathway",
y = "Normalized Enrichment Score (NES)",
title = "Top enriched pathways with respect to tolerance") +
theme_minimal(base_size = 14) +
theme(plot.title = element_text(size = 13))  # set smaller title font here)
