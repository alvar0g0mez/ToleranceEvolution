---
title: "ToleranceEvo_main"
author: "Álvaro Gómez Pérez"
date: "2025-07-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Libraries
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(stringr)
library(glue)
library(factoextra)         
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
library(jsonlite)
library(wesanderson)
library(ggrepel)
library(forcats)
library(qusage)
library(fgsea)
```

Set up
```{r}
# Significance level used for defining proteins as DE
alpha <- 0.05

# Significance level above as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")

# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.05

# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
```

Load data
```{r}
# Protein abundance dataset
protein_mat <- as.data.frame(as.matrix(fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/Processed/filtered_normalized_protein_wide.tsv"), rownames = 1))

# Metadata
metadata <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt"))

# UniProt dataframe
uniprot_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv"))
```




# 1. Initial data exploration
## 1.1. Heatmaps
### 1.1.1. Heatmap with Z-score based on median per protein - for all samples
So this is basically focusing on the variability of each protein across all the samples - removing the basal "effect" of that protein?
```{r}
classifications <- c("Strain.Type", "Treatment", "Passage")

for (classification in classifications) {
  create_heatmap(protein_mat = protein_mat,
                 metadata = metadata,
                 annotation = "single",
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = classification,
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/",
                 save_as = "png",
                 plot_name = "default",
                 heatmap_title = "All samples",
                 sample_name_size = 4,
                 cluster_columns = F)
}
```

### 1.1.2. Separate heatmaps for each treatment group
Since in the heatmap for all samples together, these cluster only around treatment group, I want to see, within each treatment group, do the samples cluster based on the other parameters?
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by Strain.Type
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Strain.Type",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/",
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
  # Produce the heatmap by passage
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Passage",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/",
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Passage", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
}
```

### 1.1.3. Let me actually separate this by Strain.Type and Passage at the same time
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by Strain.Type
  create_heatmap(protein_mat = mat,
                 annotation = "double",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 color_palette_2 = "magma",
                 metadata_column_for_annotation = "Strain.Type",
                 metadata_column_for_annotation_2 = "Passage",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/",
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
                 heatmap_title = paste("Treatment group:", treatment, sep=" "),
                 sample_name_size = 8,
                 cluster_columns = F)
}
```


## 1.2. PCA
I make 3 different ones, in each of them coloring by a different covariate, and then in the last one I combine treatment and passage
```{r}
do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Strain.Type",
       metadata_column_for_sample_name = "Sample.Name",
       threshold_for_no_imputation = 0.5,
       location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/PCA/",
       save_as = "png")

do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Passage",
       metadata_column_for_sample_name = "Sample.Name",
       threshold_for_no_imputation = 0.5,
       location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/PCA/",
       save_as = "png")

do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Treatment",
       metadata_column_for_sample_name = "Sample.Name",
       threshold_for_no_imputation = 0.5,
       location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/PCA/",
       save_as = "png")

metadata <- metadata %>%
  dplyr::mutate(Treatment_Passage = paste(Treatment, Passage, sep="_"))

do_pca(protein_mat, 
       metadata,
       metadata_column_for_annotation = "Treatment_Passage",
       metadata_column_for_sample_name = "Sample.Name",
       threshold_for_no_imputation = 0.5,
       location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/PCA/",
       save_as = "png")
```



# 2. Introduce phenotypic data (resistance and tolerance)
## 2.1. Some initial plots of the tolerance and resistance distributions
```{r}
# Load data
phenotypic_data <- fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/phenotypic_data/processed_phenotypic_data.tsv")
phenotypic_data_all_passages <- fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/phenotypic_data/processed_phenotypic_data_all_passages.tsv")

# Histograms of RAD20 and FoG20
## For all passages together
ggplot(data = phenotypic_data_all_passages, aes(x = RAD20)) +              # This is the one for the RAD20
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of RAD20 across all strains", 
       subtitle = "All passages") +
  coord_cartesian(xlim = c(3, 16),
                  ylim = c(0, 12.5))
ggplot(data = phenotypic_data_all_passages, aes(x = FoG20)) +             # This is the one for the FoG20
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of FoG20 across all strains", 
       subtitle = "All passages") +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(0, 30))

## For passages 0, 4 and 7 (the ones we have proteomics data for)
ggplot(data = subset(phenotypic_data_all_passages, Passage %in% c(0, 4, 7)), aes(x = RAD20)) +        # This is the one for the RAD20
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of RAD20 across all strains", 
       subtitle = "Passages 0, 4 and 7") +
  coord_cartesian(xlim = c(3, 16),
                  ylim = c(0, 12.5))
ggplot(data = subset(phenotypic_data_all_passages, Passage %in% c(0, 4, 7)), aes(x = FoG20)) +        # This is the one for the FoG20
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Distribution of FoG20 across all strains", 
       subtitle = "Passages 0, 4 and 7") +
  coord_cartesian(xlim = c(0, 1),
                  ylim = c(0, 30))


# Boxplots of RAD20 and FoG20s grouping by other variables 
## Grouping by Strain.Type
ggplot(data = phenotypic_data, aes(x = Strain.Type, y = RAD20, group = Strain.Type)) +
  geom_boxplot() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = Strain.Type, y = FoG20, group = Strain.Type)) +
  geom_boxplot() +
  theme_light()

## Grouping by Passage
ggplot(data = phenotypic_data, aes(x = Passage, y = RAD20, group = Passage)) +
  geom_boxplot() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = Passage, y = FoG20, group = Passage)) +
  geom_boxplot() +
  theme_light()



# Look at the correlations between RAD20, FoG20, and strain type: calculate the correlations, put them into a dataframe and create a barplot. 
strain_types <- unique(phenotypic_data_all_passages$Strain.Type)
Strain <- c()
Parameter <- c()
Correlation <- c()

for (i in 1:length(strain_types)) {
  strain_type <- strain_types[i]
  temp <- phenotypic_data_all_passages %>%
    dplyr::filter(Strain.Type == strain_type)
  
  for (parameter in c("RAD20", "FoG20")) {
    Strain <- c(Strain, strain_type)
    Parameter <- c(Parameter, parameter)
    Correlation <- c(Correlation, abs(cor(temp$Passage, temp[[parameter]])))
  }
}

correlations_to_passage <- data.frame(Strain, Parameter, Correlation)

ggplot(correlations_to_passage, aes(x = Parameter, y = Correlation, fill = Strain)) +
  geom_col(position = "dodge", col = "grey") +
  theme_light() +
  coord_cartesian(ylim = c(0, 1)) +
  labs(title = "Correlation between Strain.Type and tolerance or resistance") +
  scale_fill_manual(values= wes_palette("FantasticFox1", n = 3))
```


## 2.2. Heatmaps - sorting by resistance and tolerance levels
### 2.3.1. First of all, add RAD20 and FoG20 columns to the metadata. I am also adding an extra column, which I am calling "Resistance" - this one is just the -RAD20, and it's the one I use in order to fit the models for differential expression, so that the interpretation of the coefficients is more straightforward. This is, since the radius is inversely proportional to the resistance, I use this negative sign so that the proteins that come out as up-regulated are the ones that relate to high resistance, and the down-regulated ones correspond to low resistance, and not the other way around. 
```{r}
temp <- phenotypic_data %>%
  dplyr::select(Sample.Name, RAD20, FoG20)
metadata <- left_join(metadata, temp, by = "Sample.Name")%>%
  dplyr::mutate(Resistance = -RAD20)
```

### 2.2.2. All samples together
```{r}
# Need to remove QCs first (otherwise there are NAs in the annotation column)
protein_mat_no_QCs <- protein_mat[, !grepl("QC", colnames(protein_mat))]

# By RAD20
create_heatmap(protein_mat = protein_mat_no_QCs,
             metadata = metadata,
             annotation = "single",
             heatmap_type = "z-score",
             z_score_type = "standard",
             color_palette = "viridis",
             metadata_column_for_annotation = "RAD20",
             metadata_column_for_sample_name = "Sample.Name",
             location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
             save_as = "png",
             plot_name = "default",
             heatmap_title = "All samples",
             sample_name_size = 4,
             cluster_columns = F)

# By FoG20
create_heatmap(protein_mat = protein_mat_no_QCs,
             metadata = metadata,
             annotation = "single",
             heatmap_type = "z-score",
             z_score_type = "standard",
             color_palette = "viridis",
             metadata_column_for_annotation = "FoG20",
             metadata_column_for_sample_name = "Sample.Name",
             location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
             save_as = "png",
             plot_name = "default",
             heatmap_title = "All samples",
             sample_name_size = 4,
             cluster_columns = F)
```

### 2.2.3. Separate by treatment groups
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by RAD20
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "RAD20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_RAD20", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
  # Produce the heatmap - by FoG20
  create_heatmap(protein_mat = mat,
                 annotation = "single",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "FoG20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_FoG20", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
    # Produce the heatmap - by RAD20 and passage
  create_heatmap(protein_mat = mat,
                 annotation = "double",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Passage",
                 metadata_column_for_annotation_2 = "RAD20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_RAD20_and_passage", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
  
  # Produce the heatmap - by FoG20 and passage
  create_heatmap(protein_mat = mat,
                 annotation = "double",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Passage",
                 metadata_column_for_annotation_2 = "FoG20",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = "/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Output/Plots/heatmaps/phenotypic/",
                 save_as = "png",
                 plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_FoG20_and_passage", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "),
                 cluster_columns = F,
                 sample_name_size = 4)
}
```




# 3. Differential expression analysis
## 3.1. Simplified differential abundance analysis
```{r}
# First of all, make sure you get a version of the protein matrix and of the metadata which contain only the samples that you want to analyze 
# For example, let's say that you want to compare strains C7P and H7P, then you will do this: 
metadata_temp <- metadata %>%
  dplyr::filter(Strain.Name == "C7P"| Strain.Name == "H7P")
protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]

# If instead you wanted to compare, let's say, all samples from the Lab strain to all samples from the Heteroresistant strain, you would do it like this (commented out so that it doesn't overwrite what I wrote above)
#metadata_temp <- metadata %>%
#  dplyr::filter(Strain.Type == "Lab strain" | Strain.Type == "Heteroresistant")
#protein_mat_temp <- protein_mat[, colnames(protein_mat) %in% metadata_temp$Sample.Name]


# This is not necessary, but I like to order the columns alphabetically so that all the samples of each group are together
protein_mat_temp <- protein_mat_temp %>%
  dplyr::select(order(colnames(protein_mat_temp)))

# Now, the next step is making sure the order of the columns in the protein abundance dataset matches the order of the rows in the metadata
metadata_sorted <- metadata_temp[match(colnames(protein_mat_temp), metadata_temp$Sample.Name), ] 


# It's important that you realize that the differential abundance analysis is done based on a certain column of the metadata file. This is, if we want to compare C7P vs. H7P, these are in the Strain.Name column in the metadata, so that is the one we will be using. If we wanted to compare all samples from the Lab strain to all samples from the Heteroresistant strain, we would be using the column Strain.Type, which is the one that contains this information. This columns is used to create the design matrix, which is the one that tells lmFit() which samples belong to which group. 


# Next, make sure that the reference strain is the one you want. This is crucial for proper interpretation: upregulated or downregulated proteins will be upregulated or downregulated in the other strain, with respect to the reference one. Here we defined C7P as the reference one, since it's the lab strain. 
metadata_sorted$Strain.Name <- as.factor(metadata_sorted$Strain.Name)
metadata_sorted$Strain.Name <- relevel(metadata_sorted$Strain.Name, 
                                       ref = "C7P")

# One last check before doing the differential abundance analysis: if there are any proteins which are not detected in any of the samples of either of the groups we are comparing, we need to get rid of them (and save them elsewhere so that we can check them later if we want). This is because if we try to do the statistical testing between the two groups in such a protein, where there are no values measured for that protein at all in one of the groups, the statistical test breaks down and we get insane logFC values which are not interpretable. 

# The first thing we do though, is to remove any proteins which are not detected in any of the samples, of any of the strains we are looking at here. 
all_nas <- apply(protein_mat_temp, 1, function(x) sum(is.na(x))/ncol(protein_mat_temp) == 1)
protein_mat_temp <- protein_mat_temp[!all_nas,]

# I iterate over the proteins (the rows) and for each of them, separate the samples for one treatment and for the other, and check if either of these groups is composed solely of NAs. If so, I mark this protein to be removed, by saving it to the vector called "proteins_to_be_removed". 
strains <- levels(metadata_sorted$Strain.Name)
proteins_to_be_removed <- c()

for (i in 1:nrow(protein_mat_temp)) {
  this_protein <- rownames(protein_mat_temp)[i]
  values_in_one_strain <- as.numeric(protein_mat_temp[i, grepl(strains[1], colnames(protein_mat_temp))])
  values_in_the_other_strain <- as.numeric(protein_mat_temp[i, grepl(strains[2], colnames(protein_mat_temp))])
  
  if (sum(is.na(values_in_one_strain)) == length(values_in_one_strain) | sum(is.na(values_in_the_other_strain)) == length(values_in_the_other_strain)) {
    proteins_to_be_removed <- c(proteins_to_be_removed, this_protein)
  }
}

# Remove these proteins from the main dataset and put them into another, separate dataset, in case we want to look at them later
removed_proteins <- protein_mat_temp[rownames(protein_mat_temp) %in% proteins_to_be_removed,]
protein_mat_temp <- protein_mat_temp[!rownames(protein_mat_temp) %in% proteins_to_be_removed,]

# Create a design matrix - this is the matrix that tells the DE algorithm which samples belong to the same group. This grouping is based on the variable you specify after the ~ symbol. So, this corresponds to the name of the column in the metadata that contains the information we are working with, as I explain 2 paragraphs above. 
design <- model.matrix(~ Strain.Name, data = metadata_sorted)

# Fit model
fit <- lmFit(protein_mat_temp, design)
fit <- eBayes(fit)

# Extract results for the corresponding coefficient of the fitted model
da_results <- topTable(fit, number = Inf, adjust.method = "BH")

# The protein IDs are in the rownames now, let's put them in a column instead
da_results <- tibble::rownames_to_column(da_results, var = "protein")

# This result dataframe contains the logFC and the adjusted p-value for each protein, for the comparison of the abundance of this protein between the 2 specified groups - this is all you need to create a volcano plot. 

# Something that is quite annoying but that is important to keep in mind, is multiple testing correction. I recommend you look into the concept, since it's really important to be aware of, but basically the idea is that when you do many statistical tests at once (that is basically what we are doing here, one test for each protein, comparing it across the 2 groups), there is the probability that some of this tests provide significant results just by pure chance, without a real biological difference existing. Hence, multiple testing correction is done to be safe from this. This can be done in different ways, but the most common one for high-dimensional data (proteomics, transcriptomics, etc.) is FDR, or BH (Benjamini-Hochberg). This is done by the "adjust.method = "BH"" in the "topTable()" function. HOWEVER, I want to make sure you understand that if you do this for many pairs of strains separately, you are only correcting for multiple testing within each comparison, not taking into account all the tests you are making in all other comparisons. This is not optimal, the optimal idea would be to join the results from each of the pairwise comparisons and perform a multiple testing correction (a.k.a. p-value adjustment btw) for all of them together, and then separate them again for volcano plots and so on. 
```

## 3.2. Simplified volcano plot
```{r}
ggplot(data = da_results, aes(x = logFC, y = -log10(adj.P.Val))) +
              geom_point() +
              theme_light() +
              geom_hline(yintercept = -log10(0.05), col = "orange", linewidth = 1) +      # this adds the horizontal line at p-value = 0.05
              labs(title = glue("Differentially abundant proteins for H7P vs. C7P")) +          # this creates the plot title
              geom_vline(xintercept = 1, col = "orange", linewidth = 1) +   # this line and the following create the vertical lines, for a logFC threshold
              geom_vline(xintercept = -1, col = "orange", linewidth = 1)   # the logFC threhsold is pretty ad-hoc, I use 1 here as an example but this is not a fixed threshold like the p-value one, it can change in different datasets
```




# 4. GSEA
Load and prepare data
```{r}
# Full Entrez ID dataframe, with all genes
entrez_db <- as.data.frame(fread("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/uniprotkb_proteome_UP000000559_2025_10_19.tsv"))

# Get the corresponding KEGG IDs to the UniProt gene names, since the GSEA is performed in terms of the KEGG IDs
temp_entrez <- entrez_db %>%
  dplyr::select(Entry, GeneID) %>%
  dplyr::rename(uniprot = Entry) %>%
  dplyr::mutate(GeneID = substr(GeneID, 1, nchar(GeneID)-1))

# Process .gmt file to turn it into the list of gene set vectors we need for gsea()
gmt <- read.gmt("/home/alvaro/MyStuff/Projects/ToleranceEvo_Wenxi/Data/enrichment_analysis/databases/20251019_kegg_cal.gmt")
gmt$term <- as.character(gmt$term)

# Get a simple vector with the Entrez IDs of the proteins we detect
proteins_detected <- temp_entrez$GeneID

# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
kegg_genes <- list()
pathways <- names(gmt)

kegg_genes <- lapply(names(gmt), function(pathway) {
  intersect(gmt[[pathway]], proteins_detected)
})
names(kegg_genes) <- names(gmt)
```

## 4.1. Prepare ranked gene lists and perform GSEA
For now, my score/rank is: sign(logFC)*(-log10(adj.P.Val))
```{r}
# Rename the column with the protein names so that we can match with the UniProt dataset modified above
da_results <- da_results %>%
  dplyr::rename(uniprot = protein) %>%
  left_join(temp_entrez, by = "uniprot")

# Using as score the [-log10(p-value)*sign of the logFC], calculate this for every row in the dataset - this is, for every protein
# This score contains the information from both the p-value and the logFC - there are many different ones that can be used, but this is a kind of standard one
rankings <- sign(da_results$logFC)*(-log10(da_results$adj.P.Val))
names(rankings) <- da_results$GeneID
rankings <- sort(rankings, decreasing = TRUE)

# Sometimes, some genes have such low p-values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
max_ranking <- max(rankings[is.finite(rankings)])
min_ranking <- min(rankings[is.finite(rankings)])
rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
rankings <- sort(rankings, decreasing = TRUE)                                   # sort genes by ranking

# Get rid of rankings with emtpy names and with repeated names
length(rankings)
rankings <- rankings[!is.na(names(rankings)) & names(rankings) != ""]
rankings <- rankings[!duplicated(names(rankings))]
length(rankings)


# Run GSEA
fgseaRes <- fgsea(
    pathways = kegg_genes,
    stats = rankings,
    minSize = 10,
    maxSize = 500)
```

## 4.2. Barplots for GSEA results
```{r}
# Create a new column which marks each patwhay as up- or down-regulated based on the sign of the NES (this is kind of the equivalent of the logFC in the DEA)
# Also modify the name of the pathway, remove the ugly stuff at the beginning and substitute "_" for " ". 
fgseaRes <- fgseaRes %>%
  dplyr::mutate(direction = case_when(NES > 0 ~ "Up-regulated",
                                      NES < 0 ~ "Down-regulated",
                                      TRUE    ~ "Neutral")) %>%
  dplyr::mutate(pathway = str_replace_all(str_remove(pathway, "^[^_]*_"), "_", " "))

# Grab the top pathways, filtering based on their p-values - BE CAREFUL!: we are not filtering based on NES (kind of effect size), so need to keep an eye on that, it could be that we have significant p-values but the NES is so small that it is not biologically relevant
top_pathways <- fgseaRes %>%
  dplyr::filter(padj < alpha_enrichment) %>%
  arrange(padj)

# Create the barplot
ggplot(top_pathways, aes(x = fct_reorder(pathway, NES), y = NES, fill = direction)) +             #fct_reorder() orders the bars based on NES
        geom_col() +
        coord_flip() +                                                                                  # horizontal bars instead of vertical
        scale_fill_manual(values = c("Up-regulated" = "firebrick", "Down-regulated" = "steelblue")) +
        labs(x = "Pathway",
             y = "Normalized Enrichment Score (NES)",
             title = glue("Top enriched pathways for H7P vs. C7P")) +
        theme_minimal(base_size = 11) +
        theme(plot.title = element_text(size = 13))                                                     # set smaller title font here
```





EXTRA: This is how you download the file with the KEGG annotation in order to do the GSEA. I have already sent you this file (a .gmt file), but in case you needed to download an updated version, this is how it is done. 
This is described in a bit more detail by https://biostatsquid.com/fgsea-tutorial-gsea/ and https://www.researchgate.net/post/How_i_can_get_a_list_of_KEGG_pathways_and_its_list_of_genes. 
```{r}
#library("KEGGREST")
#library("EnrichmentBrowser")
#
##step2: check and obtain a list of entry identifiers (in this case: cal) and associated definition for a given database or a given set of database entries.
#MRSA252 <- keggList("cal")
#
##step 3: download the pathways of that organism:
#sarpathway <- downloadPathways("cal")
#
##step 4: retrieve gene sets for an organism from databases such as GO and KEGG:
#sar <- getGenesets(org = "cal", db = "kegg", cache = TRUE, return.type="list")
#
##step5: Parse and write the gene sets to a flat text file in GMT format for other pathway enrichment analysis programs (e.g., GSEA). The numbers in the name of the file ("20251019") is #the date on which it was downloaded, you should update this if you download it again later.
#writeGMT(sar, gmt.file = "~/your_desired_location/20251019_kegg_cal.gmt")
```

