---
title: "ToleranceEvo_main"
author: "Álvaro Gómez Pérez"
date: "2025-07-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


Libraries
```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(data.table)
library(limpa)
library(helperfunctions)
library(stringr)
library(glue)
library(factoextra)         # From here they are all for the heatmap/clustering section
library(dendextend)
library(staplr)
library(circlize)
library(ComplexHeatmap)
library(viridis)
library(jsonlite)
```

Set up
```{r}
working_from <- "home"

if (working_from == "home") {
  base_dir = "/home/alvaro/MyStuff/"
} else
  if (working_from == "charite") {
    base_dir = "C:/MyStuff/"
  }

save_files_to <- "s"
if (save_files_to == "s") {
  location_to_save <- "S:/AG/AG-CF-HTMS/AG-Ralser-Share/30-0156_WenxiQi-ToleranceEvo/05_DataAnalysis/11_Analysis_Alvaro/"
} else if (save_files_to == "local") {
  location_to_save <- paste(base_dir, "ToleranceEvo_Wenxi/", sep="")
}


# Significance level used for defining proteins as DE
alpha <- 0.05

# Significance level above as a plain string to use when loading or writing files
alpha_plain <- str_replace(as.character(alpha), "\\.", "")

# Separate significance level, the one used for the enrichment analysis
alpha_enrichment <- 0.1

# Significance level above as a plain string to use when loading or writing files
alpha_enrichment_plain <- str_replace(as.character(alpha_enrichment), "\\.", "")

# Log-fold change limit to be considered "biologically significant"
lfc_threshold <- 0.5
```


Load data
```{r}
# Precursor data wide format
raw_prec_data <- as.matrix(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/report_wide_filtered_norm_fully_imputed_drift_corrected_log2.csv", sep="")), rownames = 1)

# Metadata
metadata <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/metadata/metadata_processed.txt", sep="")))

# Correspondence between precursor IDs and protein IDs (UniProt) 
precursor_protein_correspondence <- as.data.frame(fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/precursor_protein_correspondence.tsv", sep="")))

# UniProt dataframe
uniprot_db <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/uniprotkb_proteome_UP000002311_2025_05_24.tsv", sep="")))
```



# 0. Some QC plots of the fully processed precursor-level data before anything else
```{r}
# Switch to long format
temp <- as.data.frame(raw_prec_data)
temp$Precursor.Id <- rownames(temp)
metadata_temp <- metadata %>%
  dplyr::select(Sample.Name, Injection)
prec_data_long <- temp %>%
  pivot_longer(cols = -Precursor.Id, 
               names_to = "Sample.Name",
               values_to = "Precursor.Normalized") %>%
  left_join(metadata_temp, by = "Sample.Name")

# Boxplot for precursor intensities along injection date
ggplot(data = prec_data_long, aes(x = Injection, y = Precursor.Normalized, group = Injection))+
  geom_boxplot() +
  theme_light()
```




# 1. Differential expression analysis
Performed with limpa. Filtering and pre-processing at the precursor level was done in the cluster, here I start from the processed (filtered, normalized, drift corrected, MAR-only imputed) data at precursor level in wide format (precursors in rows, samples in columns), summarize to protein level and perform DE analysis, both with limpa.

## 1.1. Peptide to protein summarization
```{r}
# Prepare protein ID vector matching the precursor order in the rows of the raw data, setting the order based on that of the rows of the precursor raw data
precursor_protein_correspondence <- precursor_protein_correspondence %>%
  dplyr::filter(Precursor.Id %in% rownames(raw_prec_data))
precursor_protein_correspondence <- precursor_protein_correspondence[match(rownames(raw_prec_data), precursor_protein_correspondence$Precursor.Id),]


# Remove QC samples
raw_prec_data <- raw_prec_data[, !(grepl("QC", colnames(raw_prec_data)))]

# Run summarization
summarization_results <- protein_summarize(raw_data = raw_prec_data,
                                 protein_ids = precursor_protein_correspondence$Protein.Ids,
                                 method = "limpa")
protein_mat <- summarization_results$y.protein$E

# Remove proteins which are present in less than 65% of the samples per strain - NOT NECESSARY RIGHT NOW SINCE I'M USING FULLY IMPUTED DATASET
#protein_mat <- as.data.frame(protein_mat)
#protein_mat$Precursor.Id <- rownames(protein_mat)
#protein_mat <- pivot_longer(protein_mat,                                                  # Switch to longer format for filtering
#                                 cols = !Precursor.Id,
#                                 names_to = "Strain.Name",
#                                 values_to = "Protein.Intensity") %>%
#  dplyr::filter(!is.na(Protein.Intensity)) %>%                                            # Remove rows with NAs, otherwise this filtering doesn't work (it's based on the     #                                                                                          row being present or not, not on its contents)
#  remove_uncommon_precursors_per_strain(percentage_of_samples_per_precursor = 0.65) %>%   # Filter
#  pivot_wider(names_from = "Strain.Name",                                                 # Set back to wide format
#              values_from = "Protein.Intensity") %>%
#  as.data.frame() %>%
#  set_column_as_rownames("Precursor.Id") 
#sum(is.na(protein_mat))
#sum(is.na(protein_mat))/(ncol(protein_mat)*nrow(protein_mat))

# Save protein level dataset
saveRDS(summarization_results, paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
```


## 1.2. Clustering analysis
Load protein-level data so I don't have to run the code above every time
```{r}
summarization_results <- readRDS(paste(base_dir, "ToleranceEvo_Wenxi/Data/Preprocessing_steps/protein_summarized_fully_imputed.rds", sep = ""))
protein_mat <- summarization_results$y.protein$E
```

Perform hierarchical clustering
```{r}
# Elbow method - try to figure out what number of clusters is appropriate 
clust_df <- protein_mat
clust_df <- as.data.frame(t(clust_df))         
clust_df <- scale(clust_df)

fviz_nbclust(clust_df, kmeans, method = "wss", k.max = 15)


# Create a function that can be used to perform clustering with different k values 
perform_clustering <- function(tmp, dist_method, clust_method, num_of_clusters, want_dendrogram = T, want_clust_plot = T) {
  # Get distance matrix based on Euclidean distance
  dist.euc <- dist(tmp, method = dist_method)
  
  # Perform clustering
  tree.complete <- hclust(dist.euc, method = clust_method)
  
  # Plot dendrogram
  if (want_dendrogram) {
    plot(tree.complete, cex = 0.3, 
         main = glue("Dendrogram for clustering with {clust_method} link"),
         xlab = glue("{dist_method} distance"))
    rect.hclust(tree.complete , k = num_of_clusters)
  }
  
  if (want_dendrogram) {
    dend_obj <- as.dendrogram(tree.complete)
    col_dend <- color_branches(dend_obj, k = num_of_clusters)
    labels_cex(col_dend)
    plot(col_dend)
  }
  
  # Visualize clusters
  my_clusters <- cutree(tree.complete, k = num_of_clusters)
  if (want_clust_plot) {print(fviz_cluster(list(data = tmp, cluster = my_clusters), 
                                           main = glue("Clustering by {clust_method} link"),
                                           ggtheme = theme_light()))}
  
  return(my_clusters)
}


# Use this function to do clustering: k = 2
my_clusters <- perform_clustering(clust_df, "euclidean", "complete", 6)
```

Clustering to save dendrogram to PDF
```{r}
# Set up parameters
distance_method <- "euclidean"
clustering_method <- "complete"

# Perform clustering and create dendrogram - CLUST_DF IS SCALED IN THE PREVIOUS CHUNK! IS THAT OKAY???
dist_mat <- dist(clust_df, method = distance_method)
tree <- hclust(dist_mat, method = clustering_method)
plot(tree, cex = 0.3)
hcd <- as.dendrogram(tree)

# Open a PDF for plotting; units are inches by default
pdf(paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""), width=40, height=15)

# Plot the tree into the PDF
plot(tree, cex = 0.3)

# Close the PDF file's associated graphics device (necessary to finalize the output)
dev.off()

# Rotate PDF
rotate_pdf(
  page_rotation = 90,
  input_filepath = paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""),
  output_filepath = paste(location_to_save, "Output/Plots/dendrograms/dist_method_",  distance_method, "_clust_method_", clustering_method, ".pdf", sep=""),
  overwrite = TRUE
)
```

Filter out proteins with low variability, towards the heatmaps
```{r}
protein_variability <- apply(protein_mat, 1, function(x) var(x, na.rm = T))
hist(protein_variability)
most_variable_proteins <- rownames(protein_mat)[protein_variability > 0.4]
trna_ko_high_var <- protein_mat[rownames(protein_mat) %in% most_variable_proteins,]
```


## 1.3. Heatmaps
### 1.3.1. Heatmap with Z-score based on median per protein - for all samples
So this is basically focusing on the variability of each protein across all the samples - removing the basal "effect" of that protein?
```{r}
classifications <- c("Strain.Type", "Treatment", "Passage")

for (classification in classifications) {
  create_heatmap(protein_mat = protein_mat,
               annotation = T,
               metadata = metadata,
               annotation_type = "single",
               heatmap_type = "z-score",
               z_score_type = "standard",
               color_palette = "viridis",
               metadata_column_for_annotation = classification,
               metadata_column_for_sample_name = "Sample.Name",
               location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
               save_as = "png",
               plot_name = "default",
               heatmap_title = "All samples",
               sample_name_size = 4)
}
```

### 1.3.2. Separate heatmaps for each treatment group
Since in the heatmap for all samples together, these cluster only around treatment group, I want to see, within each treatment group, do the samples cluster based on the other parameters?
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by Strain.Type
  create_heatmap(protein_mat = mat,
                 annotation = T,
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Strain.Type",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
                 save_as = "png",
                 plot_name = "custom",
                 custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "))
  
  # Produce the heatmap by passage
  create_heatmap(protein_mat = mat,
                 annotation = T,
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 metadata_column_for_annotation = "Passage",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
                 save_as = "png",
                 plot_name = "custom",
                 custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Passage", sep=""),
                 heatmap_title = paste("Treatment group", treatment, sep=" "))
}
```

### 1.3.3. Let me actually separate this by Strain.Type_Passage
```{r}
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) %in% c("QC"))]

for (treatment in treatments) {
  # Subset the protein matrix to contain only the samples in this treatment group
  samples_to_keep <- metadata$Sample.Name[metadata$Treatment == treatment]
  mat <- protein_mat[, colnames(protein_mat) %in% samples_to_keep]
  
  # Subset the metadata
  meta <- metadata[metadata$Sample.Name %in% samples_to_keep,]
  
  # Produce the heatmap - by Strain.Type
  create_heatmap(protein_mat = mat,
                 annotation = T,
                 annotation_type = "double",
                 metadata = meta,
                 heatmap_type = "z-score",
                 z_score_type = "standard",
                 color_palette = "viridis",
                 color_palette_2 = "magma",
                 metadata_column_for_annotation = "Strain.Type",
                 metadata_column_for_annotation_2 = "Passage",
                 metadata_column_for_sample_name = "Sample.Name",
                 location_to_save = paste(location_to_save, "Output/Plots/heatmaps/", sep=""),
                 save_as = "png",
                 plot_name = "custom",
                 custom_plot_name = paste("heatmap_z_score_standard_only_", treatment, "_annotated_by_Strain.Type_Passage", sep=""),
                 heatmap_title = paste("Treatment group:", treatment, sep=" "),
                 sample_name_size = 8)
}
```


## 1.4. PCA
I make 3 different ones, in each of them coloring by a different covariate
```{r}
do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Strain.Type",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")

do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Passage",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")

do_pca(protein_mat,
       metadata,
       metadata_column_for_annotation = "Treatment",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")

metadata <- metadata %>%
  dplyr::mutate(Treatment_Passage = paste(Treatment, Passage, sep="_"))

do_pca(protein_mat, 
       metadata,
       metadata_column_for_annotation = "Treatment_Passage",
       metadata_column_for_sample_name = "Sample.Name",
       location_to_save = paste(base_dir, "ToleranceEvo_Wenxi/Output/Plots/PCA/", sep=""),
       save_as = "png")
```


## 1.5. Differential expression analysis
### 1.5.1 Only for liquid - this seems to be the one we are going with from now on
```{r}
# Grab only liquid treatment samples
treatments <- unique(metadata$Treatment)[!(unique(metadata$Treatment) == "QC")]
samples_to_select <- metadata$Sample.Name[metadata$Treatment == "Liquid"]
temp_protein_mat <- protein_mat[, colnames(protein_mat) %in% samples_to_select]
reference_strain <- unique(metadata$Strain.Name[metadata$Treatment == "Liquid" &
                                             metadata$Passage == 0 &
                                             metadata$Strain.Type == "Lab strain"])[1]

# Run differential expression analysis
de_analysis_results <- de_analysis(raw_data = temp_protein_mat,
                                   metadata = metadata,
                                   method = "limma",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = reference_strain,
                                   N = 10,
                                   lfc_threshold = 0.5,
                                   alpha = 0.05)
da <- de_analysis_results$DE_df
write_json(da, path=paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), pretty = T)

# Get responsiveness df
resp <- create_responsiveness_df(da,
                                 lfc_threshold = 1,
                                 alpha = 0.05)
```

### 1.5.2. All strains together, using C0L as the reference - OLD, PROBABLY DELETE
Decided to use this one because it's the lab strain, at passage 0, and in liquid because it's supposed to have had a bit more time to grow than the solid one
```{r}
# Main DE analysis - produces the da dataframe
de_analysis_results_vs_C0L <- de_analysis(raw_data = summarization_results$y.protein,
                                   metadata = metadata,
                                   method = "limpa",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = "C0L",
                                   N = 10,
                                   lfc_threshold = 1,
                                   alpha = 0.05)
da_vs_C0L <- de_analysis_results_vs_C0L$DE_df

# From the da dataframe, create responsiveness dataframe, summarize DEPs per strain
resp_vs_C0L <- create_responsiveness_df(da = da_vs_C0L,
                                        alpha = 0.05,
                                        lfc_threshold = 1)

# Add other informative columns to resp df
temp <- metadata %>%
  dplyr::select(Strain.Name, Strain.Type, Treatment, Passage) %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
resp_vs_C0L <- left_join(resp_vs_C0L, temp, by = "Strain.Name")
```

### 1.5.3. All strains together, using C0P as the reference - OLD, PROBABLY DELETE
When using C0L as reference, I saw DEPs only in pellet and liquid+fluconazole, pointing towards the fact that it is the treatment that drives the proteome, not the strain nor the passage
```{r}
# Main DE analysis - produces the da dataframe
de_analysis_results_vs_C0P <- de_analysis(raw_data = summarization_results$y.protein,
                                   metadata = metadata,
                                   method = "limpa",
                                   strain_name_column = "Strain.Name", 
                                   sample_name_column = "Sample.Name", 
                                   reference_strain = "C0P",
                                   N = 10,
                                   lfc_threshold = 1,
                                   alpha = 0.05)
da_vs_C0P <- de_analysis_results_vs_C0P$DE_df

# From the da dataframe, create responsiveness dataframe, summarize DEPs per strain
resp_vs_C0P <- create_responsiveness_df(da = da_vs_C0P,
                                        alpha = 0.05,
                                        lfc_threshold = 1)

# Add other informative columns to resp df
temp <- metadata %>%
  dplyr::select(Strain.Name, Strain.Type, Treatment, Passage) %>%
  dplyr::distinct(Strain.Name, .keep_all = T)
resp_vs_C0P <- left_join(resp_vs_C0P, temp, by = "Strain.Name")
```


## 1.6. Boxplots for DE
### 1.6.1. DE vs. C0L
```{r}
# Per strain
ggplot(data = resp_vs_C0L, aes(x = Strain.Type, y = nDEP, group = Strain.Type, fill = Strain.Type)) +
  geom_boxplot() +
  geom_jitter(color="black", size=2, alpha=0.9) +
  theme_light() +
  xlab("Strain type") +
  ylab("nDEP") +
  labs(title = "Number of differentially expressed proteins vs. C0L",
       subtitle = "By strain type")

# Per passage
ggplot(data = resp_vs_C0L, aes(x = Passage, y = nDEP, group = Passage, fill = Passage)) +
  geom_boxplot() +
  geom_jitter(color="black", size=2, alpha=0.9) +
  theme_light() +
  xlab("Passage") +
  ylab("nDEP") +
  labs(title = "Number of differentially expressed proteins vs. C0L",
       subtitle = "By passage")

# Per treatment
ggplot(data = resp_vs_C0L, aes(x = Treatment, y = nDEP, group = Treatment, fill = Treatment)) +
  geom_boxplot() +
  geom_jitter(color="black", size=2, alpha=0.9) +
  theme_light() +
  xlab("Treatment") +
  ylab("nDEP") +
  labs(title = "Number of differentially expressed proteins vs. C0L",
       subtitle = "By treatment")
```

### 1.6.2. DE vs. C0P
```{r}
# Per strain
ggplot(data = resp_vs_C0P, aes(x = Strain.Type, y = nDEP, group = Strain.Type, fill = Strain.Type)) +
  geom_boxplot() +
  geom_jitter(color="black", size=2, alpha=0.9) +
  theme_light() +
  xlab("Strain type") +
  ylab("nDEP") +
  labs(title = "Number of differentially expressed proteins vs. C0P",
       subtitle = "By strain type")

# Per passage
ggplot(data = resp_vs_C0P, aes(x = Passage, y = nDEP, group = Passage, fill = Passage)) +
  geom_boxplot() +
  geom_jitter(color="black", size=2, alpha=0.9) +
  theme_light() +
  xlab("Passage") +
  ylab("nDEP") +
  labs(title = "Number of differentially expressed proteins vs. C0P",
       subtitle = "By passage")

# Per treatment
ggplot(data = resp_vs_C0P, aes(x = Treatment, y = nDEP, group = Treatment, fill = Treatment)) +
  geom_boxplot() +
  geom_jitter(color="black", size=2, alpha=0.9) +
  theme_light() +
  xlab("Treatment") +
  ylab("nDEP") +
  labs(title = "Number of differentially expressed proteins vs. C0P",
       subtitle = "By treatment")
```



# 2. Introduce phenotypic data
## 2.1. Some initial plots of the tolerance and resistance
```{r}
# Load data
phenotypic_data <- fread(paste(base_dir, "ToleranceEvo_Wenxi/Data/phenotypic_data/processed_phenotypic_data.tsv", sep = ""))

# Histograms of RAD20 and FoG20
ggplot(data = phenotypic_data, aes(x = RAD20)) + 
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Strains in ToleranceEvo - small scale proteomics", 
       subtitle = "Passages 0, 4 and 7")
ggplot(data = phenotypic_data, aes(x = FoG20)) + 
  geom_histogram(col = "black", fill = "grey") +
  theme_light() +
  ylab("Number of strains") +
  labs(title = "Strains in ToleranceEvo - small scale proteomics", 
       subtitle = "Passages 0, 4 and 7")

# Boxplots of RAD20 and FoG20s grouping by other variables
ggplot(data = phenotypic_data, aes(x = Strain.Type, y = RAD20, group = Strain.Type)) +
  geom_boxplot() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = Strain.Type, y = FoG20, group = Strain.Type)) +
  geom_boxplot() +
  theme_light()

# Scatterplot RAD20 vs. FoG20 and locate strains in that space
ggplot(data = phenotypic_data, aes(x = RAD20, y = FoG20, col = Strain.Name)) +
  geom_point() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = RAD20, y = FoG20, col = Strain.Type)) +
  geom_point() +
  theme_light()

ggplot(data = phenotypic_data, aes(x = RAD20, y = FoG20, col = Passage)) +
  geom_point() +
  theme_light()
```

## 2.2. Classify strains into high, medium or low tolerance and resistance based on these plots, in order to interpret proteomics results based on this
```{r}

```

## 2.3. Heatmaps - informed by resistance and tolerance levels
```{r}

```

## 2.4. PCA - colored by resistance and tolerance levels
```{r}

```




# 3. GSEA
## 3.1. Prepare ranked gene lists
For now, my score/rank is: sign(logFC)*(-log10(adj.P.Val))
```{r}
# Load list of all dataframes (one per strain) with the DE results
da <- read_json(paste(base_dir, "ToleranceEvo_Wenxi/Data/enrichment_analysis/da_", alpha_plain, "_logFC_", as.character(lfc_threshold), ".json", sep=""), simplifyVector = T)

# Now da is a collapsed dataframe with all strains, need to separate it per strain and put the resulting dataframes into a list
da_list <- list()
strains <- unique(da$Strain.Name)
for (i in 1:length(strains)) {
  strain <- strains[i]
  temp <- da %>%
    dplyr::filter(Strain.Name == strain)
  da_list[[strain]] <- temp
}

# Create empty list to put the named ranked gene lists in
ranked_genes <- list()
number_of_proteins_with_no_Entrez_ID <- c()

# Iterate over these dataframes
for (i in 1:length(da)) {
  temp <- da[[i]]
  
  # Get the corresponding Entrez IDs to these systematic gene names, since the GSEA is performed in terms of those
  temp$Protein_stable_ID <- rownames(temp)
  entrez_temp <- entrez_db %>%
    dplyr::select(Protein_stable_ID, `NCBI_gene_(formerly_Entrezgene)_ID`)
  temp <- left_join(temp, entrez_temp, by = "Protein_stable_ID")
  rownames(temp) <- NULL
  temp <- temp %>%
    dplyr::select(logFC, adj.P.Val, `NCBI_gene_(formerly_Entrezgene)_ID`) %>%
    dplyr::rename(gene_symbol = `NCBI_gene_(formerly_Entrezgene)_ID`)
  
  # Get rid of the proteins for which we don't have the Entrez ID (and save the count of how many of them there are, to check it's not too many) - otherwise GSEA doesn't work
  number_of_proteins_with_no_Entrez_ID <- c(number_of_proteins_with_no_Entrez_ID, sum(is.na(temp$gene_symbol)))
  temp <- temp %>%
    dplyr::filter(!is.na(gene_symbol))
  
  # Using as score the -log10(p-value)*sign of the logFC
  rankings <- sign(temp$logFC)*(-log10(temp$adj.P.Val))
  names(rankings) <- temp$gene_symbol
  rankings <- sort(rankings, decreasing = TRUE)
  
  # Plot
  plot(rankings)
  
  # Check max and min - to see if there is a need to correct for -Inf and +Inf - commented out, I don't think it's necessary
  #print(max(rankings))
  #print(min(rankings))
  
  # Some genes have such low p values that the signed pval is +- inf, we need to change it to the maximum * constant to avoid problems with fgsea
  # (this part is copy pasted from the link)
  max_ranking <- max(rankings[is.finite(rankings)])
  min_ranking <- min(rankings[is.finite(rankings)])
  rankings <- replace(rankings, rankings > max_ranking, max_ranking * 10)
  rankings <- replace(rankings, rankings < min_ranking, min_ranking * 10)
  rankings <- sort(rankings, decreasing = TRUE) # sort genes by ranking
  
  # Add them to the list where we are saving them
  ranked_genes[[names(da)[i]]] <- rankings
}


# Save this ranked lists so that I can use them later to pick the top 50 proteins in each strain, to look at the overlaps between major strains within families in a more unbiased manner - not really feasible for now since the distribution of the scores for the vast majority of strains is pretty much flat. I wonder how much this affects my DEA?
write_json(ranked_genes, path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/lists_of_ranked_genes_", alpha_plain, "_logFC_", as.character(lfc_threshold), sep=""),
           pretty = T)
```


## 3.2. Perform GSEA with KEGG annotation - as described by https://biostatsquid.com/fgsea-tutorial-gsea/
### Download KEGG gene lists (according to https://www.researchgate.net/post/How_i_can_get_a_list_of_KEGG_pathways_and_its_list_of_genes)
DO NOT RUN AGAIN - I used this to download the .gmt file, I just need to load it, but I left this code here in case I want to know how I did it
```{r}
#BiocManager::install("KEGGREST")
#BiocManager::install("EnrichmentBrowser")
#library("KEGGREST")
#library("EnrichmentBrowser")
#
##step2: check and obtain a list of entry identifiers (in this case: sce) and associated definition for a given database or a given set of database entries.
#MRSA252 <- keggList("sce")
#
##step 3: download the pathways of that organism:
#sarpathway <- downloadPathways("sce")
#
##step 4: retrieve gene sets for an organism from databases such as GO and KEGG:
#sar <- getGenesets(org = "sce", db = "kegg", cache = TRUE, return.type="list")
#
##step5: Parse and write the gene sets to a flat text file in GMT format for other pathway enrichment analysis programs (e.g., GSEA):
#writeGMT(sar, gmt.file = paste(base_dir, "Data/Other/enrichment_analysis/20250305_kegg_sce_gmt", sep=""))
```

### Process .gmt file to turn it into the list of gene set vectors we need for gsea()
Get a list of pathways, with each entry being a vector with the Entrez IDs for the genes involved in that pathway. Make it so that only proteins that we detect in our dataset are included here. 
```{r}
# Read in the .gmt file
gmt <- read.gmt(paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/20250305_kegg_sce_gmt", sep=""))
gmt$term <- as.character(gmt$term)

# Get a simple vector with the Entrez IDs of the proteins we detect
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "tRNA_KOs/Data/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))
yeastmine <- as.data.frame(fread(paste(base_dir, "tRNA_KOs/Data/databases/alliancemine_results_2024-11-20T11-19-04.tsv", sep="")))
proteins_detected <- match_systematic_and_standard_protein_names(data = rownames(trna_ko),
                                                                 yeastmine = yeastmine,
                                                                 input = "standard",
                                                                 simplify = T)
proteins_detected <- entrez_db$`NCBI_gene_(formerly_Entrezgene)_ID`[entrez_db$Protein_stable_ID %in% proteins_detected]

# Get our list of vectors, where each vector is a KEGG pathway and the terms in it are the genes related to it - keeping only genes which are detected in our dataset
gmt <- gmt %>%
  mutate(pathway_code = substr(term, 1, str_locate(term, "_")[1]-1), 
         pathway_name = substr(term, str_locate(term, "_")[1]+1, nchar(term)))

kegg_genes <- list()
pathways <- unique(gmt$pathway_name)
for (i in 1:length(pathways)) {
  pathway <- pathways[i]
  temp <- gmt %>%
    filter(pathway_name == pathway)
  kegg_genes[[pathway]] <- as.character(temp$gene)[as.character(temp$gene) %in% proteins_detected]
}
```

### Run GSEA
The warning I get here refers to many proteins having exactly the same rank (these are the ones we see in a horizontal line in the plots produced in 5.1.) - this should be okay, since these are the genes that were not significantly differentially expressed at all - but tbh this makes it so that I cannot really get that much info from those anyway, right? So there isn't that much of a difference between this and doing the GSEA only with DE proteins, right?? Idk
```{r}
kegg_gsea_results <- list()

for (i in 1:length(ranked_genes)) {
  kegg_gsea_results[[names(ranked_genes)[i]]] <- fgsea(pathways = kegg_genes,                                # List of gene sets to check
                                                       stats = ranked_genes[[i]],
                                                       scoreType = 'std',                                     
                                                                      # in this case we have both pos and neg rankings. if only pos or neg, set to 'pos', 'neg'
                                                       minSize = 1,
                                                       maxSize = 1000,
                                                       nproc = 1)                                             # for parallelisation
}


# This returns a list, where each element is a dataframe for the corresponding KO strain, and each row in that dataframe is a pathway. However, all pathways are included, so we are going to filter all of these dataframes to keep only the pathways that are significant in each KO strain
kegg_gsea_results_filtered <- lapply(kegg_gsea_results, function(x) filter(x, padj < alpha_enrichment))
bool <- sapply(kegg_gsea_results_filtered, function(x) nrow(x)>0)
kegg_gsea_results_filtered <- kegg_gsea_results_filtered[bool]

# Save these results
write_json(kegg_gsea_results_filtered, paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/kegg_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), pretty = T)
```


## 3.3. GSEA with GO annotation
### Get the information equivalent to that in the .gmt file and save it as gene set vectors already - code from ChatGPT
Initially I was then saving this info to an actual .gmt file to them use it, but honestly that just made everything more convoluted, I'm just going to save it as a list of vectors, as a JSON file and that's it :)
```{r}
# Step 1: Connect to Ensembl Fungi
ensembl_fungi <- useMart("fungi_mart", dataset = "scerevisiae_eg_gene", host = "https://fungi.ensembl.org")

# Step 2: Retrieve GO annotations
go_annotations <- getBM(attributes = c("ensembl_gene_id", "external_gene_name", 
                                       "go_id", "name_1006", "namespace_1003", "entrezgene_id"),
                        mart = ensembl_fungi)

# This is added by me
trna_ko <- as.data.frame(as.matrix(fread(paste(base_dir, "tRNA_KOs/Data/proteomics_data/processed_proteomics_dataframe.tsv", sep="")), rownames = 1))
go_annotations <- go_annotations %>%
  dplyr::filter(namespace_1003 != "go") %>%                                     # Pretty sure these rows are just wrong, or at least not useful to me
  dplyr::filter(ensembl_gene_id %in% rownames(trna_ko)) %>%                     # Keep only those genes which are detected in our data, so as to prevent bias
  dplyr::mutate(gene_set = case_when(namespace_1003 == "molecular_function" ~ paste(name_1006, " (MF)", sep=""),
                              namespace_1003 == "biological_process" ~ paste(name_1006, " (BP)", sep=""),
                              namespace_1003 == "cellular_component" ~ paste(name_1006, " (CC)", sep="")))

# Check the first few rows
head(go_annotations)

# Step 3: Filter for Biological Process (BP) only - not interested in using this for now
go_annotations <- go_annotations %>%
  #filter(namespace_1003 == "biological_process") %>%
  filter(go_id != "")  # Remove any empty GO terms if present

# Step 4: Build a list: GO Term -> Genes
# Use external_gene_name (common names) or ensembl_gene_id (your choice)
go_list <- split(go_annotations$entrezgene_id, go_annotations$gene_set)

# Step 5: Save this named list of vectors as a JSON file
write_json(go_list, path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_list_gmt.json", sep=""), pretty = T)
```

### Load the gene set vectors created in the previous chunk
Get a list of pathways, with each entry being a vector with the Entrez IDs for the genes involved in that pathway. Make it so that only proteins that we detect in our dataset are included here. 
```{r}
# Read in the .json file
go_gene_sets <- read_json(path = paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_list_gmt.json", sep=""), simplifyVector = T)
```

### Run GSEA
The warning I get here refers to many proteins having exactly the same rank (these are the ones we see in a horizontal line in the plots produced in 5.1.) - this should be okay, since these are the genes that were not significantly differentially expressed at all - but tbh this makes it so that I cannot really get that much info from those anyway, right? So there isn't that much of a difference between this and doing the GSEA only with DE proteins, right?? Idk
```{r}
go_gsea_results <- list()

for (i in 1:length(ranked_genes)) {
  go_gsea_results[[names(ranked_genes)[i]]] <- fgsea(pathways = go_gene_sets,                                # List of gene sets to check
                                                       stats = ranked_genes[[i]],
                                                       scoreType = 'std',                                     
                                                                      # in this case we have both pos and neg rankings. if only pos or neg, set to 'pos', 'neg'
                                                       minSize = 1,
                                                       maxSize = 1000,
                                                       nproc = 1)                                             # for parallelisation
}


# This returns a list, where each element is a dataframe for the corresponding KO strain, and each row in that dataframe is a pathway. However, all pathways are included, so we are going to filter all of these dataframes to keep only the pathways that are significant in each KO strain
go_gsea_results_filtered <- lapply(go_gsea_results, function(x) filter(x, padj < alpha_enrichment))
bool <- sapply(go_gsea_results_filtered, function(x) nrow(x)>0)
go_gsea_results_filtered <- go_gsea_results_filtered[bool]

# Save these results
write_json(go_gsea_results_filtered, paste(base_dir, "tRNA_KOs/Data/enrichment_analysis/go_gsea_results_", alpha_plain, "_logFC_", as.character(lfc_threshold), "_enrichment_alpha_", alpha_enrichment_plain, ".json", sep=""), pretty = T)
```


























Debug
```{r}
raw_data = protein_mat$y.protein
metadata = metadata
method = "limma"
strain_name_column = "Strain.Name"
sample_name_column = "Sample.Name"
reference_strain = "C0L"
lfc_threshold = 1
alpha = 0.05
N = 10
```







































